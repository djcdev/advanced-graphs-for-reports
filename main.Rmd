---
#authors: "Victor Espinosa, Alvaro Ciganda, Joel Cohen"
output: html_document

params:
  pid: 0
  reportId: 0
  server_url: ""
  token: ""
  dynamic_filter1: "Example1"
  dynamic_filter2: "Example2"
  dynamic_filter3: "Example3_dairy_complete"
  lf1: "1"
  lf2: "3"
  lf3: "2"
---

# Test


```{r setup, include=FALSE }
#knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(echo = FALSE)
# Used for data manipulation
#library(tidyr)
library(dplyr)

# Used for connections
library(RCurl)
```

```{r data_processing_functions, results='asis'}
# title_caps
# Author: Joel Cohen (Based on previously existing work)
# Description:
# 
# Takes a character array or vector of character arrays of and transforms 
# capitalizes the first letter of each word.
# 
# e.g.
# Input:
#
# c("lorem ipsum dolor sit amet", "the quick brown dog jumped") 
#
# Returns:
#
# c("Lorem Ipsum Dolor Sit Amet", "The Quick Brown Dog Jumped")
title_caps <- function (string_vec) {
  string_vec <- if (typeof(string_vec) == "character") c(string_vec) else string_vec
  vapply(strsplit(string_vec, " "), FUN = function(x) {paste(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x)), collapse = " ", sep = "")}, FUN.VALUE = "")
}

# import_data
# Author: Joel Cohen (Based on previously existing work)
# Description:
# 
# Retrieves a REDCap report's data frame with live filters applied
# If no parameters are supplied, it uses local files for the data frames.
#
# Input:
#   params:
#     pid: 0
#     reportId: 0
#     server_url: ""
#     token: ""
#     dynamic_filter1: ""
#     dynamic_filter2: ""
#     dynamic_filter3: ""
#     lf1: ""
#     lf2: ""
#     lf3: ""
#
#   live_filters:
#     field_name <chr>    option_code <chr>     option_name <chr> field_title <chr>
#     ...........................................................................
#     field1  	                  1	              option2	           Field 1
#     field2  	                  3	              option1  	         Field 2
#     instrument_one_complete     2	              Complete	       Instrument One
#     ...........................................................................
#
# Returns:
# 
# A dataframe containing the report fields with any applicable live filter.
#
# NOTE: entry ID MUST be a field in the report for this to work!
# TODO: Make local files non-static
import_data <- function(parameters, live_filters) {
  # TODO: We could filter locally if we didn't have to worry abour fields that aren't in the report
  ##########################
  # REDCap Report
  ##########################
    report_data <- read.csv(text = postForm(
        uri=parameters$server_url,
        token=parameters$token,
        content='report',
        format='csv',
        report_id=parameters$reportId,
        rawOrLabel='raw',
        rawOrLabelHeaders='raw',
        exportCheckboxLabel='false',
        returnFormat='csv',
       .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
      ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
  
    
    # If there are no live_filters active, submit the report_data
    if (nrow(live_filters) == 0) return(report_data)
    
    # If live filters are selected but there are duplicate entries 
    # in the report column report data_frame, return null
    # live filter records must be merged on the entry ids
    if (anyDuplicated(report_data)) return(data.frame())
  
  # Create filter condition to send request to redcap.
  filter_condition <- paste("[", live_filters$field_name, "] = \"", live_filters$option_code, "\"" ,sep = "", collapse = " AND ")
  
  print(filter_condition)
  
  # Create the array of field names to be returned from redcap
  report_fields <- toString(names(report_data))
  
  # All records matching live filter
  live_filtered_records <- read.csv(text = postForm(
      uri=parameters$server_url,
      token=parameters$token,
      content='record',
      fields= report_fields,
      format='csv',
      filterLogic = filter_condition,
      rawOrLabel='raw',
      rawOrLabelHeaders='raw',
      exportCheckboxLabel='false',
      returnFormat='csv',
     .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
    ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
  
  # return(report_data)
  return(
    report_data %>%
      inner_join(live_filtered_records)
  )
}

# post_project_info
# Author: Joel Cohen
# Description:
# 
# Uses the relevant parameters to request a the project info from REDCap
# 
# Input: 
#   params:
#     pid: 0
#     reportId: 0
#     server_url: ""
#     token: ""
#     dynamic_filter1: ""
#     dynamic_filter2: ""
#     dynamic_filter3: ""
#     lf1: ""
#     lf2: ""
#     lf3: ""
#
# Returns:
#
#   REDCap project info
post_project_info <- function (parameters) {
  ##########################
  # Project Dataframe
  ##########################
  read.csv(text = postForm(
    uri= parameters$server_url,
    token= parameters$token,
    content='project',
    format='csv',
    returnFormat='csv',
    .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
  ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
}

# post_data_dictionary
# Author: Joel Cohen
# Description:
# 
# Uses the relevant parameters to 
# 
# Input: 
#   params:
#     pid: 0
#     reportId: 0
#     server_url: ""
#     token: ""
#     dynamic_filter1: ""
#     dynamic_filter2: ""
#     dynamic_filter3: ""
#     lf1: ""
#     lf2: ""
#     lf3: ""
#
# Returns:
#
#   A REDCap data dictionary
post_data_dictionary <- function (parameters) {
  ##########################
  # Data Dictionary
  ##########################
  # Reads a very large string for all dd from REDCap
  read.csv(text = postForm(
    uri=parameters$server_url,
    token= parameters$token,
    content='metadata',
    format='csv',
    returnFormat='csv',
   .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
  ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
}

# parse_categories
# Author: Joel Cohen
# Description:
# 
# Takes a REDCap Data Dictionary and extracts the options for each categorical variable.
# 
# Input:
#
#   required: A REDCap Data Dictionary
# 
#   optional: A list of categorical variables
#             (Default):  "radio", "dropdown", "yesno", "truefalse", "checkbox"
#
# Returns:
#
#   A Nested list of the form:
#
#   $field_name1
#     $field_name1$code
#     [1] "1", "2", "3"
#
#     $field_name1$label
#     [1] "option1", "option2", "option3"
#
#   #field_name2
#     $field_name2$code
#     [1] "A", "B", "C"
#
#     $field_name2$label
#     [1] "optionA", "optionB", "optionC"
parse_categories <- function(data_dictionary, categoricals = c("radio", "dropdown", "yesno", "truefalse", "checkbox")) {
  categorical_indexes <- data_dictionary$field_type %in% categoricals
  
  # Create a list of categories and their options
  categories <- 
    # split the variables by | "The pipe character"
    strsplit(data_dictionary$select_choices_or_calculations[categorical_indexes], "[|]") %>% 
    # Strip white space on either end of the categories_list
    lapply(function (x) {gsub("^\\s+|\\s+$", "", x)}) %>% 
    # 
    lapply(function (x) {
      list(
        # Extract the code and remove leading and trailing whitespace
        code = gsub("^\\s+|\\s+$", "",substr(x, 1, regexpr(",", x)[1]-1)), 
        # Extract the label and remove leading and trailing whitespace
        label = gsub("^\\s+|\\s+$", "", substr(x, regexpr(",", x)[1]+1, nchar(x))) 
      )
    })
  
  # Assign each category the appropriate field name
  names(categories) <- data_dictionary$field_name[categorical_indexes] 

  return(categories) 
}

# parse_live_filters
# Author: Joel Cohen
# Description:
# 
# Creates a dataframe of the filter field, field_tile, option_code and option_label given 
# A categories list and parameters
#
# Input: 
#   parameters  - params:
#                   pid: 0
#                   reportId: 0
#                   server_url: ""
#                   token: ""
#                   dynamic_filter1: ""
#                   dynamic_filter2: ""
#                   dynamic_filter3: ""
#                   lf1: ""
#                   lf2: ""
#                   lf3: ""
#
#   categories  - A nested list of categorical fields and their options.
#
#   live_filter_status (Optional) - A named list mapping instrument filter codes to 
#                                   Incomplete, Unverified and Complete
# 
# Returns:
#
# A dataframe of the form:
#
#
# field_name <chr>    option_code <chr>     option_name <chr> field_title <chr>
# ...........................................................................
# field1  	                  1	              option2	           Field 1	
# field2  	                  3	              option1  	         Field 2	
# instrument_one_complete     2	              Complete	       Instrument One
# ...........................................................................
parse_live_filters <- function (parameters, categories, data_dictionary,live_filter_status = c("0" = "Incomplete","1"="Unverified","2" = "Complete")) {
  data.frame(field_name = c(params$dynamic_filter1, params$dynamic_filter2, params$dynamic_filter3), option_code = c(params$lf1, params$lf2, params$lf3)) %>%
  # Remove empty filters
  filter(option_code != "") %>%
  mutate(
     # Match the option_name to match to option_code from the instrument or categories list
     option_name = if_else( # Match titles for filters
        # If the field name ends in _complete
        substr(field_name, nchar(field_name)-8, nchar(field_name)) == "_complete", 
        # Let the label equal the corresponding status
        live_filter_status[option_code],
        # Otherwise...
        if_else( 
          # ... If the options code is equal to [NULL]
          option_code == "[NULL]",
          # Change it to an empty string (this is for the filter condition to send to REDCap)
          "",
          # In all other cases
          unlist(mapply(     
            # Attempt to map the option_name to the corresponding field_name, option_code in the categories list
            function(filter_name, code, options) {
              # If the code is in the corresponding field_name's options
              if (code %in% options[[filter_name]][["code"]]) 
                # Use the options label corresponding to that code
                options[[filter_name]][["label"]][which(code == options[[filter_name]][["code"]])] 
                # Otherwise, let it be empty
              else NA
            },
                field_name, option_code, MoreArgs = list(options = categories)
          ))
        )
     ),
    # Add a pretty field title
    field_title = if_else(
      # If the field_name ends in _complete
      substr(field_name, nchar(field_name)-8, nchar(field_name)) == "_complete",
      # Remove _complete, split it over underscores, and capitalize the first letter of each word\
      # e.g. Example_instrument_complete => Example Instrument
      gsub("_", " ", substr(field_name, 0, nchar(field_name)-9)) %>% title_caps(),
       # Otherwise try to match it with field label from the data_dictionary
      right_join(data_dictionary, data.frame(field_name = field_name), by = "field_name")[["field_label"]]
    )
  )
} 
```

```{r, results=}

```


```{r data_input}
# Get report metadata
project_info <- post_project_info(params)
data_dictionary <- post_data_dictionary(params)

# Get a list of categories and their options
categories <- parse_categories(data_dictionary)

# Retrieve the live filters
live_filters <- parse_live_filters(params, categories, data_dictionary)

# Retrieve report data
report_data <- import_data(params, live_filters)
```

```{r}
print(project_info)
print(data_dictionary)
print(categories)
print(live_filters)
print(report_data)
```

