---
#authors: "Victor Espinosa, Alvaro Ciganda, Joel Cohen"
output: 
  html_document:
    css: "advanced_graphs.css"
  

params:
  pid: 0
  reportId: 0
  server_url: ""
  token: ""
  dynamic_filter1: ""
  dynamic_filter2: ""
  dynamic_filter3: ""
  lf1: ""
  lf2: ""
  lf3: ""
---

# Test
```{=html}
<style type="text/css">
.main-container {
  position: absolute;
  max-width: 100%;
  margin-left: 0%;
  margin-right: 0%;
}
</style>
```

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, results = "asis")


# Used for connections
library(RCurl)

# --- Used for creating plots ---
# Used for many nice looking plots
library(ggplot2)

# Used for likert plots
library(likert)

# Used to get good color palettes
library(RColorBrewer)
getPalette = colorRampPalette(brewer.pal(8, "Set2"))
library(viridis)

# Used for tables
library(kableExtra)

# Necessary for all percents in likert plot
library(plyr, include.only = c("ddply", "."))

# Used to create maps
library(leaflet)

# Used to create network graphs
library(igraph)

# Used to extract trailing numbers from checkboxes
library(stringr)

# -------------------------------

# --- Used for data manipulation ---
library(dplyr)
library(tidyr)
options(dplyr.summarise.inform = FALSE)

# Used to create dataframe with category lists for likert
# library(data.table, exclude = c("hour", "isoweek", "mday", "minute", "month", "quarter", "second", "wday", "week", "yday", "year"))
# ----------------------------------
```

```{r data_processing_functions, eval = TRUE}
source("./data_manipulation.R")

```

```{r custom_plots, eval = TRUE}
source("./custom_plots.R")
```


```{r data_input, eval = TRUE}
# TODO: The if statement is temporary and allows for testing on sample data
if (params$pid != 0) {
  # Get report metadata
  project_info <- post_project_info(params)
  data_dictionary <- post_data_dictionary(params)
  
  # Get a list of categories and their options
  categories <- parse_categories(data_dictionary)
  
  # Retrieve the live filters
  live_filters <- parse_live_filters(params, categories, data_dictionary)
  
  # Retrieve report data
  report_data <- import_data(params, data_dictionary$field_name[1], live_filters)
} else {
  # Data dictionary is same one from Advanced Graphs - Demo Project
  data_dictionary <- read.csv(file = "./sample/sample_data_dictionary.csv", header = TRUE)
  categories <- parse_categories(data_dictionary)
  
  project_info <- data.frame(project_title = c("Sample Data"))
  
  live_filters <- data.frame(c())
  
  # Report data was randomly sampled from Advanced Graphs - Demo Project
  report_data <- read.csv(file = "./sample/sample_report_data.csv", header = TRUE)
}

# Fields to ignore if any of these words appear anywhere in the field name
ignored_names_numeric = c("latitude", "longitude", "latitud", "longitud")

# text validation strings to consider as a numerical column
accepted_text_validation = c("integer", "number", "float", "decimal")

# Get numerical fields
numeric_fields <- data_dictionary %>%
  filter(
    # The field name is in the report
    field_name %in% names(report_data)
    # The field type isn't null
    & !is.na(field_type) 
    # If the field type is text but there is no text validation, don't include (text field)
    & !(field_type == "text" & is.na(text_validation_type_or_show_slider_number)) 
    # Include only fields where either:
    & (
      # The field type is calc
      field_type == "calc" 
      # If the field type is text it uses a recognized validation format
      | (field_type == "text" 
          & grepl(paste0("*",accepted_text_validation, "*", collapse = "|"), text_validation_type_or_show_slider_number))
      )
      # And is not one of the ignored_names
    & !grepl(paste0("*", ignored_names_numeric, "*", collapse = "|"), field_name)
  ) %>%
  select(field_name) %>%
  unlist()

# Radio or dropdown fields
radio_categories <- data_dictionary %>%
  # Select fields from the data dictionary
  filter(
    # Where they are of "radio" type
    field_type %in% c("radio", "dropdown", "yesno", "truefalse")
    # The field name is in the report data
    & field_name %in% names(report_data)
    # And there are options
    & select_choices_or_calculations != "") %>%
  # Turn them into a list of category attributes
  parse_categories()

# Get date fields
date_fields <- data_dictionary %>%
  # Select only fields in the report
  filter(field_name %in% names(report_data)
         # Select only fields that start with 'date'
         & substr(text_validation_type_or_show_slider_number, 1, 4) == "date") %>%
  # Select the field name
  select(field_name) %>%
  # Return field names in vector
  unlist() %>%
  unname()

# Turn columns into factors and date
report_data <- report_data %>%
  mutate(
    # Select radio-like categories
    across(names(radio_categories), 
            function(column)
              # Turn them into factors, putting their names with their labels
              addNA(factor(column, levels = radio_categories[[cur_column()]][["options_code"]], labels = radio_categories[[cur_column()]][["options_label"]]), 
                  # Adding an NA level if there are any NAs
                  ifany = TRUE), .names = "{.col}"),
     # Select all the date fields
     across(all_of(date_fields), 
           # Convert them to date
           .fns = as.Date, 
           # Try these formats
           tryFormats = c("%m/%d/%Y", "%Y-%m-%d", "%Y/%m/%d"),
           .names = "{col}")    
    )
  

# Create list of labels
names_to_labels <- data_dictionary$field_label
names(names_to_labels) <- data_dictionary$field_name
```

## Advanced Graphs 

### `r project_info$project_title`
#### project pid `r params$pid`
#### Number of results returned: `r nrow(report_data)`
##### Live filter(s)
###### `r if (nrow(live_filters) > 0) paste0(live_filters$field_title, " = ", live_filters$option_name, collapse = "\n")`
<!--TODO: fix '=' when no live filters selected -->
```{r, eval = FALSE}
# TODO: Delete
# print(project_info)
print(data_dictionary)
# print(categories)
print(live_filters)
print(report_data)
```

### Likert plots

```{r likert_plots}
# Likert types
like_likert <- c("dropdown", "radio")
key_likert_words <- c("not useful", "not at all useful", "difficult", "none of my needs", "strongly disagree", "somewhat disagree", "completely disagree", "quite dissatisfied", "very dissatisfied", "Extremely dissatisfied", "poor", "never", "worse", "severely ill", "inutil", "in\u00fatil", "completamente inutil", "completamente in\u00fatil", "dificil", "dif\u00edcil", "ninguna de mis necesidades", "totalmente en desacuerdo", "parcialemnte en desacuerdo", "completamente en desacuerdo", "muy insatisfecho(a)", "totalmente insatisfecho(a)", "nunca", "peor", "gravemente enfermo")

# From the data dictionary
likert_groups <- data_dictionary %>%
  filter(
    # Select only the fields that are in the report
    field_name %in% names(report_data)
    # That have a field type that can be likert
    & field_type %in% like_likert
    # And whose options contain a likert keyword
    & grepl(paste0("*",tolower(key_likert_words), "*", collapse = "|"), tolower(select_choices_or_calculations))
  ) %>%
  # Group the fields that have the same options
  group_by(select_choices_or_calculations) %>%
  # Take a list of field names and labels
  summarise(field_name = list(field_name), field_label = list(field_label)) %>%
  # Parse the categories into a useful format
  parse_categories()

# For each set of fields that share options
for (likert_group in likert_groups) {
    report_data %>%
      # Select these fields from the data dictionary
      transmute(across(all_of(likert_group$field_name), .names = "{likert_group$field_label}")) %>%
      (function(data) {
        # If any of the fields contain an NA
       if (any(is.na(data))) {
         return(
           # Add an NA field to each factor
           transmute(data, across(.fns = addNA))
         )
       }
        # Otherwise return the data as is
        return(data)
      }) %>%
      # Pass this dataframe to the custom likert
      custom_likert() %>%
      # print this plot
      print()
}
```

### Scatter plots  

```{r scatter_plots, results='asis'}
# # Fields to ignore if any of these words appear anywhere in the field name
# ignored_names = c("latitude", "longitude", "latitud", "longitud")
# 
# # text validation strings to consider as a numerical column
# accepted_text_validation = c("integer", "number", "float", "decimal")
# 
# # Get numerical fields
# numeric_fields <- data_dictionary %>%
#   filter(
#     # The field name is in the report
#     field_name %in% names(report_data)
#     # The field type isn't null
#     & !is.na(field_type) 
#     # If the field type is text but there is no text validation, don't include (text field)
#     & !(field_type == "text" & is.na(text_validation_type_or_show_slider_number)) 
#     # Include only fields where either:
#     & (
#       # The field type is calc
#       field_type == "calc" 
#       # If the field type is text it uses a recognized validation format
#       | (field_type == "text" 
#           & grepl(paste0("*",accepted_text_validation, "*", collapse = "|"), text_validation_type_or_show_slider_number))
#       )
#       # And is not one of the ignored_names
#     & !grepl(paste0("*", ignored_names, "*", collapse = "|"), field_name)
#   ) %>%
#   select(field_name) %>%
#   unlist()

scatter_fields <- c(date_fields, numeric_fields)

for (x_field in scatter_fields) {
  # And each field considered y
  # If the entire column is not empty
  if (!all(is.na(report_data[,x_field])))
    for (y_field in scatter_fields) {
      # Excluding field_x = field_y and empty y_field
      if ((y_field != x_field)& !all(is.na(report_data[,y_field]))) {
          report_data %>%
            transmute(
              across(all_of(x_field), .names = "{names_to_labels[x_field]}"),
              across(all_of(y_field), .names = "{names_to_labels[y_field]}")
            ) %>%
            na.omit() %>%
          (function(data) {
            if (nrow(data) > 0) {
              cat("<center><h4>", 
                  names_to_labels[y_field], "vs", names_to_labels[x_field],
                  "</h4></center><div class=\"clearfix\"><div class=\"img-container\">")
              data %>%
              custom_scatter(x = !!sym(names_to_labels[x_field]), y = !!sym(names_to_labels[y_field]), line = FALSE) %>%
                plot()
              cat("</div>")
              cat("<div class=\"img-container\">")
              data %>%
              custom_scatter(x = !!sym(names_to_labels[x_field]), y = !!sym(names_to_labels[y_field]), line = TRUE) %>%
                plot()
              cat("</div></div>")
            }
          })
      }
    } 
}

# # Get date fields
# date_data_fields <- data_dictionary %>%
#   # Select only fields in the report
#   filter(field_name %in% names(report_data)
#          # Select only fields that start with 'date'
#          & substr(text_validation_type_or_show_slider_number, 1, 4) == "date") %>%
#   # Select the field name
#   select(field_name) %>%
#   # Return field names in vector
#   unlist()
# 
# # if (length(date_data_fields) > 1)
# #   date_pairs <- combn(date_data_fields, 2, simplify = FALSE)
# #   else date_pairs <- combn(date_data_fields, 2)
# 
# # For each date_field (x in date - date plots)
# for (date_field in date_data_fields) {
#   # If the date field isn't empty
#   for (numeric_field in numerical_data_fields) {
#     report_data %>%
#       transmute(
#         # Get the date field
#         across(all_of(date_field),
#                # Convert name to label
#                .names = "{names_to_labels[.col]}"),
#         across(all_of(numeric_field), .names = "{names_to_labels[.col]}")
#       ) %>%
#       na.omit() %>%
#       (function(data) {
#         if (nrow(data) > 0) {
#               
#         }
#       })
#       # Plot date as x and numeric as y
#       custom_scatter(report_data[,c(..date_field_x, ..numeric_field)], names_to_labels[c(date_field_x, numeric_field)], date_fields = date_field_x)
#       # Plot numeric as x and date as y
#       # custom_scatter(report_data[,c(..numeric_field, ..date_field_x)], names_to_labels[c(numeric_field, date_field_x)], date_fields = date_field_x)
#   }
# }
# 
#   # For each date_field
#   for (date_field_y in date_data_fields) {
#     # If the x date field and y date field are different
#     if (date_field_x != date_field_y){
#       # Create a custom scatter plot with the two date fields
#       custom_scatter(report_data[,c(..date_field_x, ..date_field_y)], names_to_labels[c(date_field_x, date_field_y)], date_fields = c(date_field_x, date_field_y))
#     }
#   }
# }

```

### Category counts

```{r bar_plots}
# Get a parsed list of each checkbox field
checkbox_fields <- data_dictionary %>%
  filter(field_type == "checkbox") %>%
  parse_categories()

for (checkbox_field in checkbox_fields) {
  # If there is at least on field of the form "field_name___[0-9]+" in the report_data
  # create a plot
  if (any(grepl(paste0(checkbox_field$field_name, "___[0-9]+\\b"), names(report_data)))) {
    checkbox_plot <- report_data %>%
      # Select each column of the report data that matches the current checkbox field
      select(matches(paste0(checkbox_field$field_name, "___[0-9]+\\b"))) %>%
      # Let each column be it's own level in a factor column
      pivot_longer(cols = everything())  %>%
      # remove NA entries
      na.omit() %>%
      group_by(name, .drop = FALSE) %>%
      # Get the count and proportion for each of the checkboxes
      summarise(count = sum(value), percent = count/n())  %>%
      # Use the field label as the name 
      transmute(
        # Use the field_label as the name for the options
        "{checkbox_field$field_label}" := 
          # replace the field_name__1 with the corresponding label
          factor(checkbox_field$options_label[str_extract(name, "[0-9]+\\b")], levels = checkbox_field$options_label), 
        # Include counts and percents
        count, 
        percent) %>%
      # Create a custom bar plot
      custom_bars(x = !!sym(checkbox_field$field_label), y = count, label2 = percent, percent = TRUE) %>% print()
  }
}

# # Radio or dropdown fields
# radio_categories <- data_dictionary %>%
#   # Select fields from the data dictionary
#   filter(
#     # Where they are of "radio" type
#     field_type %in% c("radio", "dropdown", "yesno", "truefalse")
#     # The field name is in the report data
#     & field_name %in% names(report_data)
#     # And there are options
#     & select_choices_or_calculations != "") %>%
#   # Turn them into a list of category attributes
#   parse_categories()

for (radio_category in radio_categories) {
  # If the entire column isn't NA
  if (!all(is.na(report_data[[radio_category$field_name]])))
  report_data %>%
    transmute(
      # Select the column
      across(all_of(radio_category$field_name),
             # Rename it the field label
             .names = radio_category$field_label)
      ) %>%
    # Get a count of each category
    group_by_all(.drop = FALSE) %>%
    summarise(count = n()) %>%
    mutate(percent = count/sum(count)) %>%
    # Create a custom bar plot
    custom_bars(x = !!sym(radio_category$field_label), y = count, label2 = percent, percent = TRUE) %>%
    # Print it
    print()
}

```

### Numerical bar plots

```{r numerical_bar_plots, eval=TRUE}
# For each radio category
for (category in radio_categories) {
  # If the category column isn't empty
  if (!all(is.na(report_data[[category$field_name]])))
  # For each numeric field
  for (numeric_field in numeric_fields) {
    # If the numeric column isn't empty
    if (!all(is.na(report_data[[numeric_field]])))
    report_data %>%
      transmute(
        # Turn radio category into factor
        across(all_of(category$field_name), .names = "category"),
        # Select the numeric column
        across(all_of(numeric_field), .names = "numeric")
      ) %>% 
      # Remove entries where the numeric column is NA
      filter(!is.na(numeric)) %>% #print()
      # Group by the category and do not drop categories that do no show up in the data
      # TODO: Is this the behavior we want
      group_by(category, .drop = FALSE) %>%
      # Get the mean for each group, 0 if there are no numeric fields
      summarise(sum = sum(numeric, na.rm = TRUE), count = n(), mean = round(sum/(if (count > 0) count else 1), 1)) %>%
      (function (data){
        # Create side by side plots
        side_by_side(
          data %>%
            # Rename the fields based on their field names
            transmute(
              "{category$field_label}" := category, 
              # Get the mean
              "{paste0(names_to_labels[numeric_field], \" (mean)\")}" := mean) %>%
          # Create a custom bar plot
          custom_bars(x = !!sym(category$field_label), 
                      y = !!sym(paste0(names_to_labels[numeric_field], " (mean)")))
          # End of plot 1
          ,
          # Beginning of plot 2
          data %>%
            transmute(
              "{category$field_label}" := category, 
              # Get the sum (total)
              "{paste0(names_to_labels[numeric_field], \" (total)\")}" := sum) %>%
          # Create a custom bar plot
          custom_bars(x = !!sym(category$field_label), y = !!sym(paste0(names_to_labels[numeric_field], " (total)")))
        ,
        # Title for side by side plots
        title = paste0(names_to_labels[numeric_field], " per ", category$field_label)
        )

      })
  }
}
```
### Stacked and grouped bars
```{r stacked_bars, results='asis', message=FALSE}
# A "New names:" warning is introduced by the custom_crosstabs function
# TODO: Fix warning from custom_crosstabs

if (length(radio_categories) > 1) {
  radio_pairs <- combn(radio_categories, 2, simplify = FALSE)


  for (radio_pair in radio_pairs) {
    report_data %>%
      transmute(
        # Select the x and y categories
        across(all_of(radio_pair[[1]]$field_name), .names = "{radio_pair[[1]]$field_label}"),
        # Repeat for second column
        across(all_of(radio_pair[[2]]$field_name), .names = "{radio_pair[[2]]$field_label}")
      ) %>%
      # Group by both columns and do not drop levels where there are no matches
      group_by_all(.drop = FALSE) %>%
      # Get a count of each pair of levels
      summarise(count = n()) %>%
      # Ungroup data
      ungroup() %>%
      (function(data) {
        # Create a custom stacked  and a grouped bar plot 
        # with the first field as x and print them side by side
        side_by_side(
          # stacked bar plot
          data %>%
            custom_stacked(
              # x and y are the categories
              x = !!sym(radio_pair[[1]]$field_label), 
              y = !!sym(radio_pair[[2]]$field_label), 
              # fill is the data to fill the bars with
              fill = count, 
              title = paste0(radio_pair[[1]]$field_label, " and ", radio_pair[[2]]$field_label))
          ,
          data %>%
            custom_stacked(
              x = !!sym(radio_pair[[1]]$field_label), 
                           y = !!sym(radio_pair[[2]]$field_label), 
                           fill = count, 
                           title = paste0(radio_pair[[1]]$field_label, " and ", radio_pair[[2]]$field_label),
                           # position = dodge indicates grouped bar plot
                           position = "dodge",
                           maxgroups = 17)
          ,
          # The title to include
          title = paste0(radio_pair[[1]]$field_label, " and ", radio_pair[[2]]$field_label)
        )
        
      # Create a two more custom stacked and a grouped bar plots 
      # with the first field as y and print and them side by side
        side_by_side(
          data %>%
          # Create a custom stacked bar plot with the data with the first field as y
            custom_stacked(
              x = !!sym(radio_pair[[2]]$field_label), 
              y = !!sym(radio_pair[[1]]$field_label), 
              fill = count, 
              title = paste0(radio_pair[[2]]$field_label, " and ", radio_pair[[1]]$field_label))
          ,
          data %>%
          custom_stacked(
              x = !!sym(radio_pair[[2]]$field_label), 
              y = !!sym(radio_pair[[1]]$field_label), 
              fill = count, 
              title = paste0(radio_pair[[2]]$field_label, " and ", radio_pair[[1]]$field_label),
              position = "dodge",
              maxgroups = 17)
          ,
          title = paste0(radio_pair[[2]]$field_label, " and ", radio_pair[[1]]$field_label)
        )

      side_by_side(
        data %>%
          # Pass it to the custom crosstab function
          custom_crosstab(
            x = !!sym(radio_pair[[1]]$field_label),
            y = !!sym(radio_pair[[2]]$field_label),
            total = count,
            column_spanner = radio_pair[[2]]$field_label)
        ,
        data %>%
          # Pass it to the custom crosstab function
          custom_crosstab(
            x = !!sym(radio_pair[[2]]$field_label),
            y = !!sym(radio_pair[[1]]$field_label),
            total = count,
            column_spanner = radio_pair[[1]]$field_label)
      )
    })

  }
}

```

### Maps

```{r maps, message=FALSE, out.width = "100%", fig.align="center", fig.height=8, fig.width=10}
# If a field_name contains one of these keywords it will be considered a longitude/latitude column
# ADD keywords in order of longest starting string to shortest
# e.g. c("longitude", "longitud", "long", "l")
longitude_keywords <- c("longitude", "longitud")
latitude_keywords <- c("latitude", "latitud")

longitudes <- data_dictionary %>%
  # Choose field_names that contain longitude keywords
  filter(field_name %in% names(report_data) 
         & grepl(paste0("*", longitude_keywords,"*", collapse = "|"), field_name) ) %>%
  transmute(
    # Include the field name
    field_name,
    # The field label
    field_label, 
    # The name with the latitude keyword removed
    stripped_name = sapply(regmatches(field_name, gregexpr(pattern = paste0(longitude_keywords, collapse = "|"), field_name), invert = TRUE), paste0, collapse = "", USE.NAMES = FALSE))

# Repeat for latitude keywords
latitudes <- data_dictionary %>%
  filter(field_name %in% names(report_data)
         & grepl(paste0("*", latitude_keywords,"*", collapse = "|"), field_name)) %>%
  transmute(
    field_name, 
    field_label, 
    stripped_name = sapply(regmatches(field_name, gregexpr(pattern = paste0(latitude_keywords, collapse = "|"), field_name), invert = TRUE), paste0, collapse = "", USE.NAMES = FALSE))

# Join the latitude and longitude dataframes by the stripped names
coordinate_fields <- inner_join(longitudes, latitudes, by = "stripped_name") 

if (nrow(coordinate_fields) > 0) {
  coordinate_fields <- coordinate_fields %>%
  # For each stripped name (e.g. sending_) 
  # names and labels for the latitudea nd longitude column
  {mapply(FUN = function(longitude_name, latitude_name, longitude_label, latitude_label) {
    list(
      longitude_name = longitude_name,
      latitude_name = latitude_name,
      longitude_label = longitude_label,
      latitude_label =latitude_label
    )
  }, longitude_name = .[,"field_name.x"], latitude_name = .[,"field_name.y"], longitude_label = .[,"field_label.x"], latitude_label = .[,"field_label.y"], SIMPLIFY = FALSE)}
} else {
  coordinate_fields <- list()
}

if (length(coordinate_fields) > 0) {
# Create a list of maps by
maps <- lapply(coordinate_fields,
              function(coordinate_field) {
                # Taking the corespinding latitude and longitude columns from the report data
                report_data %>%
                  # Nameing them longitude and latitude respectively
                  transmute(
                    across(all_of(coordinate_field$longitude_name), .names = "longitude"),
                    across(all_of(coordinate_field$latitude_name), .names = "latitude")
                  ) %>%
                  # Remove na entries
                  na.omit() %>%
                  # Get a column counting each longitude and latitude
                  group_by_all() %>%
                  summarise(count = n()) %>%
                  # Send it to our map function
                  custom_map(title = paste0(coordinate_field$longitude_label, " vs ", coordinate_field$latitude_label))
              }
)

# Use taglist to create a list of maps that can be displayed
htmltools::tagList(maps)
}
```

### Network graphs

```{r network_graphs, out.width = "100%", fig.align="center"}
# Take the text fields from the data dictionary
text_fields <- data_dictionary %>%
  filter(field_type == "text" & field_name %in% names(report_data)) %>%
  # Create a list of field_names and field_labels
  {mapply(
    FUN = function(field_name, field_label) {
      list(
        field_name = field_name,
        field_label = field_label
      )
    }, .[["field_name"]], .[["field_label"]],
    SIMPLIFY = FALSE
  )}

# If there are 2 or more text fields
if (length(text_fields) > 1)
# For each text pair
for (text_pair in combn(text_fields, 2, simplify = FALSE)) {
  # If both of the columns aren't null
  if(!all(is.na(report_data[[text_pair[[1]]$field_name]]))
     && !all(is.na(report_data[[text_pair[[2]]$field_name]])))
    # Get the columns from the report data
    report_data %>%
            # Turn them into factors and add NA as a factor if there are any
            transmute(across(all_of(c(text_pair[[1]]$field_name, text_pair[[2]]$field_name)),
                      function(column) {
                        addNA(factor(column), ifany = TRUE)
                      }
                        , .names = "{names_to_labels[.col]}")
            ) %>%
            # Create a graph from the data
            graph_from_data_frame(directed = TRUE) %>%
            # Plot it
            plot(edge.width = 1,
           main = paste0(text_pair[[1]]$field_label, " vs. " ,text_pair[[2]]$field_label),
           cex.main = 100,
           sub = "",
           edge.arrow.width = 0.3,
           vertex.size = 3,
           edge.arrow.size = 0.5,
           vertex.size2 = 3,
           vertex.label.cex = .75,
           asp = .65,
           margin = -0.1)
}
```



