---
#authors: "Victor Espinosa, Alvaro Ciganda, Joel Cohen"
output: html_document

params:
  pid: 0
  reportId: 0
  server_url: ""
  token: ""
  dynamic_filter1: ""
  dynamic_filter2: ""
  dynamic_filter3: ""
  lf1: ""
  lf2: ""
  lf3: ""
---

# Test


```{r setup, include=FALSE }
#knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(echo = FALSE)


# Used for connections
library(RCurl)

# --- Used for creating plots ---

# Used for likert plots
library(likert)

# Necessary for all percents in likert plot
library(plyr, include.only = c("ddply", "."))

# -------------------------------

# --- Used for data manipulation ---
#library(tidyr)
library(dplyr)
options(dplyr.summarise.inform = FALSE)

# Used to create dataframe with category lists for likert
library(data.table, exclude = c("hour", "isoweek", "mday", "minute", "month", "quarter", "second", "wday", "week", "yday", "year"))
# ----------------------------------
```

```{r data_processing_functions, results='asis'}
# title_caps
# Author: Joel Cohen (Based on previously existing work)
# Description:
# 
# Takes a character array or vector of character arrays of and transforms 
# capitalizes the first letter of each word.
# 
# e.g.
# Input:
#
# c("lorem ipsum dolor sit amet", "the quick brown dog jumped") 
#
# Returns:
#
# c("Lorem Ipsum Dolor Sit Amet", "The Quick Brown Dog Jumped")
title_caps <- function (string_vec) {
  string_vec <- if (typeof(string_vec) == "character") c(string_vec) else string_vec
  vapply(strsplit(string_vec, " "), FUN = function(x) {paste(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x)), collapse = " ", sep = "")}, FUN.VALUE = "")
}

# import_data
# Author: Joel Cohen (Based on previously existing work)
# Description:
# 
# Retrieves a REDCap report's data frame with live filters applied
# If no parameters are supplied, it uses local files for the data frames.
#
# Input:
#   params:
#     pid: 0
#     reportId: 0
#     server_url: ""
#     token: ""
#     dynamic_filter1: ""
#     dynamic_filter2: ""
#     dynamic_filter3: ""
#     lf1: ""
#     lf2: ""
#     lf3: ""
#
#   live_filters:
#     field_name <chr>    option_code <chr>     option_name <chr> field_title <chr>
#     ...........................................................................
#     field1  	                  1	              option2	           Field 1
#     field2  	                  3	              option1  	         Field 2
#     instrument_one_complete     2	              Complete	       Instrument One
#     ...........................................................................
#
# Returns:
# 
# A dataframe containing the report fields with any applicable live filter.
#
# NOTE: entry ID MUST be a field in the report for this to work!
# TODO: Make local files non-static
import_data <- function(parameters, record_id, live_filters) {
  # TODO: We could filter locally if we didn't have to worry abour fields that aren't in the report
  ##########################
  # REDCap Report
  ##########################
    report_data <- read.csv(text = postForm(
        uri=parameters$server_url,
        token=parameters$token,
        content='report',
        format='csv',
        report_id=parameters$reportId,
        rawOrLabel='raw',
        rawOrLabelHeaders='raw',
        exportCheckboxLabel='false',
        returnFormat='csv',
       .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
      ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
  
    
    # If there are no live_filters active, submit the report_data
    if (nrow(live_filters) == 0) return(report_data)
    
    # If live filters are selected but there are duplicate entries 
    # in the report column report data_frame, return null
    # live filter records must be merged on the entry ids
    if (anyDuplicated(report_data)) return(data.frame())
  
  # Create filter condition to send request to redcap.
  filter_condition <- paste("[", live_filters$field_name, "] = \"", live_filters$option_code, "\"" ,sep = "", collapse = " AND ")
  
  
  # Create the array of field names to be returned from redcap
  report_fields <- toString(names(report_data))
  
  # All records matching live filter
  live_filtered_records <- read.csv(text = postForm(
      uri=parameters$server_url,
      token=parameters$token,
      content='record',
      fields= report_fields,
      format='csv',
      filterLogic = filter_condition,
      rawOrLabel='raw',
      rawOrLabelHeaders='raw',
      exportCheckboxLabel='false',
      returnFormat='csv',
     .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
    ), header = TRUE, sep = ",", stringsAsFactors = FALSE)

  return(
    report_data %>%
      group_by_all() %>%
      mutate(adv_graph_internal_duplicates_id = row_number()) %>% 
      inner_join(live_filtered_records %>%
                 select(names(report_data)) %>%
                 group_by_all() %>%
                 mutate(adv_graph_internal_duplicates_id = row_number())    
                ) %>%
      select(-adv_graph_internal_duplicates_id)# TODO: Test this solutions
  )
}

# post_project_info
# Author: Joel Cohen
# Description:
# 
# Uses the relevant parameters to request a the project info from REDCap
# 
# Input: 
#   params:
#     pid: 0
#     reportId: 0
#     server_url: ""
#     token: ""
#     dynamic_filter1: ""
#     dynamic_filter2: ""
#     dynamic_filter3: ""
#     lf1: ""
#     lf2: ""
#     lf3: ""
#
# Returns:
#
#   REDCap project info
post_project_info <- function (parameters) {
  ##########################
  # Project Dataframe
  ##########################
  read.csv(text = postForm(
    uri= parameters$server_url,
    token= parameters$token,
    content='project',
    format='csv',
    returnFormat='csv',
    .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
  ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
}

# post_data_dictionary
# Author: Joel Cohen
# Description:
# 
# Uses the relevant parameters to 
# 
# Input: 
#   params:
#     pid: 0
#     reportId: 0
#     server_url: ""
#     token: ""
#     dynamic_filter1: ""
#     dynamic_filter2: ""
#     dynamic_filter3: ""
#     lf1: ""
#     lf2: ""
#     lf3: ""
#
# Returns:
#
#   A REDCap data dictionary
post_data_dictionary <- function (parameters) {
  ##########################
  # Data Dictionary
  ##########################
  # Reads a very large string for all dd from REDCap
  read.csv(text = postForm(
    uri=parameters$server_url,
    token= parameters$token,
    content='metadata',
    format='csv',
    returnFormat='csv',
   .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
  ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
}

# parse_categories
# Author: Joel Cohen
# Description:
# 
# Takes a REDCap Data Dictionary and extracts the options for each categorical variable.
# 
# Input:
#
#   required: A REDCap Data Dictionary
# 
#   optional: A list of categorical variables
#             (Default):  "radio", "dropdown", "yesno", "truefalse", "checkbox"
#
# Returns:
#
#   A Nested list of the form:
#
#   $field_name1
#     $field_name1$code
#     [1] "1", "2", "3"
#
#     $field_name1$label
#     [1] "option1", "option2", "option3"
#
#   $field_name2
#     $field_name2$code
#     [1] "A", "B", "C"
#
#     $field_name2$label
#     [1] "optionA", "optionB", "optionC"
parse_categories <- function(data_dictionary, categoricals = c("radio", "dropdown", "yesno", "truefalse", "checkbox")) {
  categorical_indexes <- data_dictionary$field_type %in% categoricals
  
  # Create a list of categories and their options
  categories <- 
    # split the variables by | "The pipe character"
    strsplit(data_dictionary$select_choices_or_calculations[categorical_indexes], "[|]") %>% 
    # Strip white space on either end of the categories_list
    lapply(function (x) {gsub("^\\s+|\\s+$", "", x)}) %>% 
    # 
    lapply(function (x) {
      list(
        # Extract the code and remove leading and trailing whitespace
        code = gsub("^\\s+|\\s+$", "",substr(x, 1, regexpr(",", x)[1]-1)), 
        # Extract the label and remove leading and trailing whitespace
        label = gsub("^\\s+|\\s+$", "", substr(x, regexpr(",", x)[1]+1, nchar(x))) 
      )
    })
  
  # Assign each category the appropriate field name
  names(categories) <- data_dictionary$field_name[categorical_indexes] 

  return(categories) 
}

# parse_live_filters
# Author: Joel Cohen
# Description:
# 
# Creates a dataframe of the filter field, field_tile, option_code and option_label given 
# A categories list and parameters
#
# Input: 
#   parameters  - params:
#                   pid: 0
#                   reportId: 0
#                   server_url: ""
#                   token: ""
#                   dynamic_filter1: ""
#                   dynamic_filter2: ""
#                   dynamic_filter3: ""
#                   lf1: ""
#                   lf2: ""
#                   lf3: ""
#
#   categories  - A nested list of categorical fields and their options.
#
#   live_filter_status (Optional) - A named list mapping instrument filter codes to 
#                                   Incomplete, Unverified and Complete
# 
# Returns:
#
# A dataframe of the form:
#
#
# field_name <chr>    option_code <chr>     option_name <chr> field_title <chr>
# ...........................................................................
# field1  	                  1	              option2	           Field 1	
# field2  	                  3	              option1  	         Field 2	
# instrument_one_complete     2	              Complete	       Instrument One
# ...........................................................................
parse_live_filters <- function (parameters, categories, data_dictionary,live_filter_status = c("0" = "Incomplete","1"="Unverified","2" = "Complete")) {
  data.frame(field_name = c(params$dynamic_filter1, params$dynamic_filter2, params$dynamic_filter3), option_code = c(params$lf1, params$lf2, params$lf3)) %>%
  # Remove empty filters
  filter(option_code != "") %>%
  mutate(
     # Match the option_name to match to option_code from the instrument or categories list
     option_name = if_else( # Match titles for filters
        # If the field name ends in _complete
        substr(field_name, nchar(field_name)-8, nchar(field_name)) == "_complete", 
        # Let the label equal the corresponding status
        live_filter_status[option_code],
        # Otherwise...
        if_else( 
          # ... If the options code is equal to [NULL]
          option_code == "[NULL]",
          # Change it to an empty string (this is for the filter condition to send to REDCap)
          "",
          # In all other cases
          unlist(mapply(     
            # Attempt to map the option_name to the corresponding field_name, option_code in the categories list
            function(filter_name, code, options) {
              # If the code is in the corresponding field_name's options
              if (code %in% options[[filter_name]][["code"]]) 
                # Use the options label corresponding to that code
                options[[filter_name]][["label"]][which(code == options[[filter_name]][["code"]])] 
                # Otherwise, let it be empty
              else NA
            },
                field_name, option_code, MoreArgs = list(options = categories)
          ))
        )
     ),
    # Add a pretty field title
    field_title = if_else(
      # If the field_name ends in _complete
      substr(field_name, nchar(field_name)-8, nchar(field_name)) == "_complete",
      # Remove _complete, split it over underscores, and capitalize the first letter of each word\
      # e.g. Example_instrument_complete => Example Instrument
      gsub("_", " ", substr(field_name, 0, nchar(field_name)-9)) %>% title_caps(),
       # Otherwise try to match it with field label from the data_dictionary
      right_join(data_dictionary, data.frame(field_name = field_name), by = "field_name")[["field_label"]]
    )
  )
} 
```

```{r custom_plots}
# custom_likert
# Author: Joel Cohen
# Description:
#   
#   Takes a dataframe containing factors and returns a likert plot
#
#   Input:
#     
#     A dataframe containing factors with the same levels
#
#   Output:
#     
#     A likert plot
custom_likert <- function(x) {
  likert.bar.plot(likert(x),
            as.percent = TRUE,
            low.color="forestgreen",
            high.color = "red3",
            neutral.color = "lightgoldenrod",
            horizontal=TRUE,
            plot.percents = TRUE,
            xscale.components=xscale.components.top.HH,
            yscale.components=yscale.components.right.HH,
            xlimEqualLeftRight=FALSE,
            xTickLabelsPositive=TRUE,
            reverse=FALSE,
            xlab = "Percent",
            ylab.right = "")
}

# custom_scatter
# Author: Joel Cohen
# Description:
#   
#   Takes a dataframe containing two numerical columns and field labels and returns a scatterplot
#
#   Input:
#     
#     A dataframe containing two numerical columns and a list of field labels
#
#   Output:
#     
#     A scatter plot
custom_scatter <- function(data, field_labels = NULL, date_fields = c()) {
  # If any number of columns other than two is provided, stop
  if (ncol(data) != 2) stop(paste0("custom_scatter takes a dataframe with two columns, (",ncol(data),") provided."))
  
  # If field_labels is NULL use the names of the passed dataframes
  if (is.null(field_labels)) {
    field_labels <- names(data)
  } else if (length(field_labels) != 2 || typeof(field_labels) != "character") {
    stop("field_labels must be a character vector or character list of length 2")
  }
  
  data %>%
    mutate(across(all_of(date_fields), as.Date, tryFormats = c("%m/%d/%Y", "%Y-%m-%d", "%Y/%m/%d"))) %>%
    na.omit() %>%
    (function(fixed_data) {
      if (nrow(fixed_data) != 0) {
        plot(
          fixed_data,
          main = paste0(field_labels, collapse = " vs "),
          xlab = field_labels[1],
          ylab = field_labels[2],
          type = "p",
          xaxt = "n",
          yaxt = "n",
          # TODO: Make point sizes increase for repeated (y?) values
          #cex= points_to_plot[,3]
          pch=19, 
          col="blue"
        )
        if (length(date_fields) == 0) {
          axis(side = 1, labels = TRUE, las = 1)
          axis(side = 2, labels = TRUE, las = 1)
        } else if (length(date_fields) == 1) {
          axis.Date(side = which(names(fixed_data) == date_fields), fixed_data[[date_fields]], labels = TRUE, las = 1)
          axis(side = which(names(fixed_data) != date_fields), labels = TRUE, las = 1)
        } else {
          axis.Date(side = 1, fixed_data[[date_fields[1]]], labels = TRUE, las = 1)
          axis.Date(side = 2, fixed_data[[date_fields[2]]], labels = TRUE, las = 1)
        }
      }
    })
}

# custom_scatter_date
# Author: Joel Cohen
# Description:
#   
#   Takes a dataframe containing a date column as x and a numerical column as y and field labels and returns a scatterplot
#
#   Input:
#     
#     A dataframe containing a date column as the first field, a numerical column as the second field and a (optional) list of field labels
#
#   Output:
#     
#     A date scatter plot
custom_scatter_date <- function(data, field_labels = NULL) {
  # If any number of columns other than two is provided, stop
  if (ncol(data) != 2) stop(paste0("custom_scatter_date takes a dataframe with two columns, (",ncol(data),") provided."))
  
  # If field_labels is NULL use the names of the passed dataframes
  if (is.null(field_labels)) {
    field_labels <- names(data)
  } else if (length(field_labels) != 2 || typeof(field_labels) != "character") {
    stop("field_labels must be a character vector or character list of length 2")
  }
  
  data %>%
    na.omit() %>%
    (function(data) {
      if (nrow(data) != 0) {
        plot(
          data,
          main = paste0(field_labels, collapse = " vs "),
          xlab = field_labels[1],
          ylab = field_labels[2],
          type = "p",
          xaxt = "n",
          yaxt = "n",
          # TODO: Make point sizes increase for repeated (y?) values
          #cex= points_to_plot[,3]
          pch=19, 
          col="blue"
        )
      }
    })
}
```


```{r data_input}
# TODO: The if statement is temporary and allows for testing on sample data
if (params$pid != 0) {
  # Get report metadata
  project_info <- post_project_info(params)
  data_dictionary <- post_data_dictionary(params)
  
  # Get a list of categories and their options
  categories <- parse_categories(data_dictionary)
  
  # Retrieve the live filters
  live_filters <- parse_live_filters(params, categories, data_dictionary)
  
  # Retrieve report data
  report_data <- import_data(params, data_dictionary$field_name[1], live_filters)
} else {
  # Data dictionary is same one from Advanced Graphs - Demo Project
  data_dictionary <- read.csv(file = "./sample/sample_data_dictionary.csv", header = TRUE)
  categories <- parse_categories(data_dictionary)
  
  project_info <- data.frame(project_title = c("Sample Data"))
  
  live_filters <- c()
  
  # Report data was randomly sampled from Advanced Graphs - Demo Project
  report_data <- read.csv(file = "./sample/sample_report_data.csv", header = TRUE)
}
# Create list of labels
names_to_labels <- data_dictionary$field_label
names(names_to_labels) <- data_dictionary$field_name
```

## Advanced Graphs 

### `r project_info$project_title`
#### project pid `r params$pid`
#### Number of results returned: `r nrow(report_data)`
##### Live filter(s)
###### `r if (nrow(live_filters) > 0) paste0(live_filters$field_title, " = ", live_filters$option_name, collapse = "\n")`
<!--TODO: fix '=' when no live filters selected -->
```{r}
# TODO: Delete
# print(project_info)
#print(data_dictionary)
# print(categories)
# print(live_filters)
# print(report_data)
```


```{r likert_plots}
# Likert types
like_likert <- c("dropdown", "radio")
key_likert_words <- c("not useful", "not at all useful", "difficult", "none of my needs", "strongly disagree", "somewhat disagree", "completely disagree", "quite dissatisfied", "very dissatisfied", "Extremely dissatisfied", "poor", "never", "worse", "severely ill", "inutil", "in\u00fatil", "completamente inutil", "completamente in\u00fatil", "dificil", "dif\u00edcil", "ninguna de mis necesidades", "totalmente en desacuerdo", "parcialemnte en desacuerdo", "completamente en desacuerdo", "muy insatisfecho(a)", "totalmente insatisfecho(a)", "nunca", "peor", "gravemente enfermo")

# Get categorical fields that can be made into likert graphs
likert_categories <- data_dictionary[data_dictionary$field_type %in% like_likert & data_dictionary$field_name %in% names(report_data), "field_name"]

#likert_categories

# TODO: Other checks such as making sure common categories share an instrument

# Get the levels for each categorical field
likert_candidate_levels <- lapply(likert_categories, function(x) {categories[[x]][["code"]]})
likert_candidate_labels <- lapply(likert_categories, function(x) {categories[[x]][["label"]]})

# Create a dataframe for each grouping of categorical variables
likert_groups <- data.table(likert_candidate_levels, likert_candidate_labels) %>%
  group_by(likert_candidate_levels, likert_candidate_labels) %>%
  summarise(indices = list(cur_group_rows()), category_names = list(likert_categories[cur_group_rows()])) %>%
  filter(any(grepl(paste0("*",tolower(key_likert_words), "*", collapse = "|"), tolower(likert_candidate_labels))))

# TODO: delete
# print(likert_categories)
# print(likert_candidate_levels)
# print(likert_groups)

for (group_index in seq_len(nrow(likert_groups))) {
  # Get raw data for this group and check for NA's
  raw_group_data <- report_data %>%
    select(unlist(likert_groups$category_names[group_index]))

  # If there are any NA's
  if (any(is.na(raw_group_data))) {
    # Replace them with character vectors "NA"
    raw_group_data <- raw_group_data %>%
      replace(is.na(.), "NA")

    # Add an "NA" level
    likert_groups$likert_candidate_levels[[group_index]] <- append(likert_groups$likert_candidate_levels[[group_index]], "NA")

    # As well as a corresponding NA label
    likert_groups$likert_candidate_labels[[group_index]] <- append(likert_groups$likert_candidate_labels[[group_index]], "NA")
  }

  # Create a dataframe out of corresponding factors for each group
  likert_group_df <- data.frame(lapply(raw_group_data, factor, levels = likert_groups$likert_candidate_levels[[group_index]], labels = likert_groups$likert_candidate_labels[[group_index]]))
  
  # Swap the names with the corresponding labels in the data dictionary
  names(likert_group_df) <- data_dictionary[data_dictionary$field_name %in% names(likert_group_df), "field_label"]

  # Print a likert bar plot for this group
  print(custom_likert(likert_group_df))
}
```

```{r scatter_plots}
# Fields to ignore if any of these words appear anywhere in the field name
ignored_names = c("latitude", "longitude", "latitud", "longitud")

accepted_text_validation = c("integer", "number", "float", "decimal")

# Get numerical fields
numerical_data_fields <- data_dictionary %>%
  filter(
    # The field name is in the report
    field_name %in% names(report_data)
    # The field type isn't null
    & !is.na(field_type) 
    # If the field type is text but there is no text validation, don't include (text field)
    & !(field_type == "text" & is.na(text_validation_type_or_show_slider_number)) 
    # Include only fields where either:
    & (
      # The field type is calc
      field_type == "calc" 
      # If the field type is text it uses a recognized validation format
      | (field_type == "text" 
          & grepl(paste0("*",accepted_text_validation, "*", collapse = "|"), text_validation_type_or_show_slider_number))
      )
      # And is not one of the ignored_names
    & !grepl(paste0("*", ignored_names, "*", collapse = "|"), field_name)
  ) %>%
  select(field_name) %>%
  unlist()

for (x_field in numerical_data_fields) {
  # And each field considered y
  for (y_field in numerical_data_fields) {
    # Excluding field_x = field_y
    if (y_field != x_field)
      custom_scatter(report_data[, c(x_field, y_field)], names_to_labels[c(x_field, y_field)])
  } 
}

# Get date fields
date_data_fields <- data_dictionary %>%
  # Select only fields in the report
  filter(field_name %in% names(report_data)
         # Select only fields that start with 'date'
         & substr(text_validation_type_or_show_slider_number, 1, 4) == "date") %>%
  # Select the field name
  select(field_name) %>%
  # Return field names in vector
  unlist()

# For each date_field (x in date - date plots)
for (date_field_x in date_data_fields) {
  # And numeric_field
  for (numeric_field in numerical_data_fields) {
      # Plot date as x and numeric as y
      custom_scatter(report_data[,c(date_field_x, numeric_field)], names_to_labels[c(date_field_x, numeric_field)], date_fields = date_field_x)
      # Plot numeric as x and date as y
      custom_scatter(report_data[,c(numeric_field, date_field_x)], names_to_labels[c(numeric_field, date_field_x)], date_fields = date_field_x)
  }
  
  # For each date_field
  for (date_field_y in date_data_fields) {
    if (date_field_x != date_field_y){
      custom_scatter(report_data[,c(date_field_x, date_field_y)], names_to_labels[c(date_field_x, date_field_y)], date_fields = c(date_field_x, date_field_y))
    }
  }
}

```


