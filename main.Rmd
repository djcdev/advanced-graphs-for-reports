---
#authors: "Victor Espinosa, Alvaro Ciganda, Joel Cohen"
title: "Advanced Graphs"
output: 
  html_document:
    css: "advanced_graphs.css"
  

params:
  pid: 0
  reportId: 0
  server_url: ""
  token: ""
  dynamic_filter1: ""
  dynamic_filter2: ""
  dynamic_filter3: ""
  lf1: ""
  lf2: ""
  lf3: ""
---
<!-- The following block is used so we can use the full width of the page -->
```{=html}
<style type="text/css">
.main-container {
  position: absolute;
  max-width: 100%;
  margin-left: 0%;
  margin-right: 0%;
}
</style>
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, eval = T, results = "asis")

# Used for connections to get data from redcap
library(RCurl)
library(XML)

# --- Used for creating plots ---
# Necessary for all percents in likert plot
library(plyr, include.only = c("ddply", "."))

# Used to extract trailing numbers from checkboxes
library(stringr)
# -------------------------------

# --- Used for data manipulation ---
library(dplyr)
library(tidyr)
# This allows us to group by all without
# being warned which groups are bing used
options(dplyr.summarise.inform = FALSE)
# ----------------------------------
```

```{r data_processing_functions, include = FALSE, eval = TRUE}
source("./data_manipulation.R")
```

```{r custom_plots, include = FALSE, eval = TRUE}
source("./custom_plots.R")
```


```{r data_input, eval = TRUE}
# TODO: The if statement is temporary and allows for testing on sample data
if (params$pid != 0) {
  # Get report metadata
  project_info <- post_project_info(params)
  data_dictionary <- post_data_dictionary(params)
  
  categories <- parse_categories(data_dictionary)
  
  # Retrieve the live filters
  live_filters <- parse_live_filters(params, categories, data_dictionary)
  
  # Retrieve report data
  report_data <- import_data(params, data_dictionary$field_name[1], live_filters)
} else {
  # Data dictionary is same one from Advanced Graphs - Demo Project
  data_dictionary <- read.csv(file = "./sample/sample_data_dictionary.csv", header = TRUE)
  categories <- parse_categories(data_dictionary)
  
  project_info <- data.frame(project_title = c("Sample Data"))
  
  live_filters <- data.frame(c())
  
  # Report data was randomly sampled from Advanced Graphs - Demo Project
  report_data <- read.csv(file = "./sample/sample_report_data.csv", header = TRUE)
}

# Remove HTML if there is any  
html_labels <- data_dictionary[data_dictionary$field_name %in% names(report_data), "field_label"] %>%
  lapply(function(x) htmlParse(x,  asText = TRUE) %>% xpathApply("//body//text()[not(ancestor::script)][not(ancestor::style)][not(ancestor::noscript)]", xmlValue) %>% paste0(collapse = "")) %>% unlist()

# Remove any entries created which hold only whitespace
html_labels <- html_labels[which(nchar(trimws(html_labels, whitespace = "[ \t\r\n\xA0\f]")) != 0)]

# Fix duplicate label names
data_dictionary[data_dictionary$field_name %in% names(report_data), "field_label"] <- vctrs::vec_as_names(html_labels, repair = "unique", quiet = TRUE)

##### Get likert groups #####
# field_types that are candidates for likert
like_likert <- c("dropdown", "radio")
# If any of the following keywords are contained in the options
# it will be considered a likert category
key_likert_words <- c("not useful", "not at all useful", "difficult", "none of my needs", "strongly disagree", "somewhat disagree", "completely disagree", "quite dissatisfied", "very dissatisfied", "Extremely dissatisfied", "poor", "never", "worse", "severely ill", "inutil", "infatil", "completamente inutil", "completamente infatil", "dificil", "ninguna de mis necesidades", "totalmente en desacuerdo", "parcialemnte en desacuerdo", "completamente en desacuerdo", "muy insatisfecho(a)", "totalmente insatisfecho(a)", "nunca", "peor", "gravemente enfermo")

# From the data dictionary
likert_groups <- data_dictionary %>%
  filter(
    # Select only the fields that are in the report
    field_name %in% names(report_data)
    # That have a field type that can be likert
    & field_type %in% like_likert
    # And whose options contain a likert keyword
    & grepl(paste0("*",tolower(key_likert_words), "*", collapse = "|"), tolower(select_choices_or_calculations))
  ) %>%
  # Group the fields that have the same options
  group_by(select_choices_or_calculations) %>%
  # Take a list of field names and labels
  summarise(field_name = list(field_name), field_label = list(field_label)) %>%
  # Parse the categories into a useful format (collapses field_name, field_label, options_code and options_label using field_name, field_label, and select_choices_or_calculations)
  parse_categories()

#############################


##### Get numeric fields #####

# Fields to ignore if any of these words appear anywhere in the field name
# when searching for numeric fields
ignored_names_numeric = c("latitude", "longitude", "latitud", "longitud")

# text validation strings to consider as a numerical column
accepted_text_validation = c("integer", "number", "float", "decimal")

# Get numerical fields
numeric_fields <- data_dictionary %>%
  filter(
    # The field name is in the report
    field_name %in% names(report_data)
    # The field type isn't null
    & !is.na(field_type) 
    # If the field type is text but there is no text validation, don't include (text field)
    & !(field_type == "text" & is.na(text_validation_type_or_show_slider_number)) 
    # Include only fields where either:
    & (
      # The field type is calc
      field_type == "calc" 
      # or field type is text it and it uses a recognized validation format
      | (field_type == "text" 
          & grepl(paste0("*",accepted_text_validation, "*", collapse = "|"), text_validation_type_or_show_slider_number))
      )
      # And does not contain one of the ignored keywords
    & !grepl(paste0("*", ignored_names_numeric, "*", collapse = "|"), field_name)
  ) %>%
  select(field_name) %>%
  # Turns a single column into a vector
  unlist()

##############################

##### Get categorical fields #####

# The field types to be considered categorical variables
categorical_types <- c("radio", "dropdown", "yesno", "truefalse")

# Radio or dropdown fields
radio_categories <- data_dictionary %>%
  # If the field type is yesno or truefalse but there is no select_choices_or_calculations
  # Add select_choices_or_calculations
  mutate(select_choices_or_calculations = 
           case_when(
             select_choices_or_calculations != "" ~ select_choices_or_calculations,
             field_type == "yesno" ~ "1, Yes | 0, No",
             field_type == "truefalse" ~ "1, True | 0, False",
             TRUE ~ select_choices_or_calculations
           )
         ) %>%
  # Select fields from the data dictionary
  filter(
    # Where they are of "radio" type
    field_type %in% categorical_types
    # The field name is in the report data
    & field_name %in% names(report_data)
    # And there are options
    & select_choices_or_calculations != "") %>%
  # Turn them into a list of category attributes
  parse_categories()

# Get date fields
date_fields <- data_dictionary %>%
  # Select only fields in the report
  filter(field_name %in% names(report_data)
         # Select only fields that start with 'date'
         & substr(text_validation_type_or_show_slider_number, 1, 4) == "date") %>%
  # Select the field name
  transmute(field_name,
            try_format = case_when(text_validation_type_or_show_slider_number == "date_dmy" ~ "%%Y-%m-%d",
                                   text_validation_type_or_show_slider_number == "date_mdy"~ "%Y-%m-%d",
                                   text_validation_type_or_show_slider_number == "date_ymd"~ "%Y-%m-%d",
                                   text_validation_type_or_show_slider_number == "datetime_dmy"~ "%Y-%m-%d %H:%M",
                                   text_validation_type_or_show_slider_number == "datetime_mdy"~ "%Y-%m-%d %H:%M",
                                   text_validation_type_or_show_slider_number == "datetime_ymd"~ "%Y-%m-%d %H:%M",
                                   text_validation_type_or_show_slider_number == "datetime_seconds_dmy"~ "%Y-%m-%d %H:%M:%S",
                                   text_validation_type_or_show_slider_number == "datetime_seconds_mdy"~ "%Y-%m-%d %H:%M:%S",
                                   text_validation_type_or_show_slider_number == "datetime_seconds_ymd"~ "%Y-%m-%d %H:%M:%S"))
  #select(field_name) %>%
  # Return field names in vector
  #unlist() %>%
  #unname()

##################################

# Turn factor and date columns into factors and date types
report_data <- report_data %>%
  mutate(
    # Select radio-like categories
    across(names(radio_categories), 
            function(column)
              # Turn them into factors, putting their names with their labels
              addNA(factor(column, levels = radio_categories[[cur_column()]][["options_code"]], labels = radio_categories[[cur_column()]][["options_label"]]), 
                  # Adding an NA level if there are any NAs
                  ifany = TRUE), .names = "{.col}"),
     # Select all the date fields
     across(all_of(date_fields$field_name), 
           # Convert them to date
           .fns = ~as.POSIXct(replace(.x, .x == "", NA), tryFormat = date_fields$try_format[date_fields$field_name == cur_column()], optional = TRUE), 
           # Try these formats,
           .names = "{.col}")    
    ) 


# Change date fields to just field_names of date_fields
date_fields <- date_fields$field_name

# Create list of labels
# This is used to extract the text labels from the field names
names_to_labels <- data_dictionary$field_label
names(names_to_labels) <- data_dictionary$field_name
```


```{r, results = 'asis', eval = TRUE}
cat("\n###", project_info$project_title)
cat("\n### project pid", params$pid)
cat("\n#### Number of records returned:", nrow(report_data))

cat("\n##### Live filter(s): ")
if (nrow(live_filters) > 0 ) {
  cat("\n######", paste0(live_filters$field_label, " = ", live_filters$options_label, collapse = "\n\n###### "))
} else {
  cat("\n###### None")
}

```



```{r likert_plots}
if (length(likert_groups) > 0)
  cat("<h3>Likert plots</h3>")

# For each set of fields that share options
for (likert_group in likert_groups) {
    report_data %>%
      data.frame() %>%
      # Select these fields from the data dictionary
      # Across changes the field_names to their corresponding field labels 
      transmute(across(all_of(likert_group$field_name), .names = "{likert_group$field_label}")) %>%
      (function(data) {
        # If any of the fields contain an NA
       if (any(is.na(data))) {
         return(
           # Add an NA field to each factor
           transmute(data, across(.fns = addNA))
         )
       }
        # Otherwise return the data as is
        return(data)
      }) %>%
      # Pass this dataframe to the custom likert
      custom_likert() %>%
      # print this plot
      print()
}
```


```{r scatter_plots, results='asis'}
scatter_fields <- c(date_fields, numeric_fields)

if (length(scatter_fields) > 1)
  cat("<h3>Scatter plots  </h3>")

for (x_field in scatter_fields) {
  # And each field considered y
  # If the entire column is not empty
  if (!all(is.na(report_data[,x_field])))
    for (y_field in scatter_fields) {
      # Excluding field_x = field_y and empty y_field
      if ((y_field != x_field)& !all(is.na(report_data[,y_field]))) {
          report_data %>%
            # Get x and y fields and name them by their respective labels
            transmute(
              across(all_of(x_field), .names = "{names_to_labels[x_field]}"),
              across(all_of(y_field), .names = "{names_to_labels[y_field]}")
            ) %>%
            # Remove NA entries from the data
            na.omit() %>%
          (function(data) {
            # If there is data to plot
            if (nrow(data) > 0) {
              # Plot the scatter plot and line plot side by side
              side_by_side(
                data %>%
                  custom_scatter(x = !!sym(names_to_labels[x_field]), y = !!sym(names_to_labels[y_field]), line = FALSE)
              ,
                data %>%
              custom_scatter(x = !!sym(names_to_labels[x_field]), y = !!sym(names_to_labels[y_field]), line = TRUE)
              ,
              title = paste0(names_to_labels[y_field], " vs ", names_to_labels[x_field])
              )
            }
          })
      }
    } 
}

```


```{r bar_plots}
# Get a parsed list of each check box field
checkbox_fields <- data_dictionary %>%
  filter(field_type == "checkbox") %>%
  parse_categories()

if (length(radio_categories) > 0)
  cat("<h3>Category counts</h3>")

for (checkbox_field in checkbox_fields) {
  # If there is at least one field of the form "field_name___[0-9]+" in the report_data
  # create a plot
  if (any(grepl(paste0(checkbox_field$field_name, "___[0-9]+\\b"), names(report_data)))) {
    report_data %>%
      # Select each column of the report data that matches the current checkbox field
      select(matches(paste0(checkbox_field$field_name, "___[0-9]+\\b"))) %>%
      # Let each column be it's own level in a factor column
      pivot_longer(cols = everything())  %>%
      # remove NA entries
      na.omit() %>%
      group_by(name, .drop = FALSE) %>%
      # Get the count and proportion for each of the checkboxes
      summarise(count = sum(value), percent = count/n())  %>%
      # Use the field label as the name 
      transmute(
        # Use the field_label as the name for the options
        "{checkbox_field$field_label}" := 
          # replace the field_name__1 with the corresponding label
          factor(checkbox_field$options_label[str_extract(name, "[0-9]+\\b")], levels = checkbox_field$options_label), 
        # Include counts and percents
        count, 
        percent) %>%
       (function(data) {
         side_by_side(
           data %>%
           custom_bars(x = !!sym(checkbox_field$field_label), y = count, label2 = percent, percent = TRUE)
           ,
           data %>%
           custom_pie(x = !!sym(checkbox_field$field_label), y = count, title = paste0("Count of ", checkbox_field$field_label))
           ,
           title = paste0("Count of ", checkbox_field$field_label)
         )
       })
      # Create a custom bar plot
  }
}

for (radio_category in radio_categories) {
  # If the entire column isn't NA
  if (!all(is.na(report_data[[radio_category$field_name]])))
  report_data %>%
    transmute(
      # Select the column
      across(all_of(radio_category$field_name),
             # Rename it the field label
             .names = radio_category$field_label)
      ) %>%
    # Get a count of each category
    group_by_all(.drop = FALSE) %>%
    summarise(count = n()) %>%
    # Add a percent column
    mutate(percent = count/sum(count)) %>%
    # Create a custom bar plot
    # Print it
    (function(data) {
         side_by_side(
           data %>%
           custom_bars(x = !!sym(radio_category$field_label), y = count, label2 = percent, percent = TRUE)
           ,
           data %>%
           custom_pie(x = !!sym(radio_category$field_label), y = count)
           ,
           title = paste0("Count of ", radio_category$field_label)
         )
       })
}

```


```{r numerical_bar_plots}
if (length(radio_categories) > 0 && length(numeric_fields) > 0)
  cat("<h3>Numerical bar plots</h3>")

# For each radio category
for (category in radio_categories) {
  # If the category column isn't empty
  if (!all(is.na(report_data[[category$field_name]])))
  # For each numeric field
  for (numeric_field in numeric_fields) {
    # If the numeric column isn't empty
    if (!all(is.na(report_data[[numeric_field]])))
    report_data %>%
      transmute(
        # Select the cateorical column
        across(all_of(category$field_name), .names = "category"),
        # Select the numeric column
        across(all_of(numeric_field), .names = "numeric")
      ) %>% 
      # Remove entries where the numeric column is NA
      filter(!is.na(numeric)) %>%
      # Group by the category and do not drop categories that do no show up in the data
      # TODO: Do we want to drop or keep empty levels
      group_by(category, .drop = FALSE) %>%
      # Get the mean for each group, 0 if there are no numeric fields
      summarise(sum = sum(numeric, na.rm = TRUE), mean = if (n() == 0) 0 else round(mean(numeric, na.rm = TRUE), 2), min = if (n() == 0) 0 else min(numeric, na.rm = TRUE), max = if (n() == 0) 0 else max(numeric, na.rm = TRUE)) %>%
      (function (data){
        # Side by side mean bar chart and pie chart
        side_by_side(
          data %>%
            # Rename the fields based on their field names
            transmute(
              "{category$field_label}" := category, 
              # Get the mean
              "{paste0(names_to_labels[numeric_field], \" (mean)\")}" := mean) %>%
          # Create a custom bar plot
          custom_bars(x = !!sym(category$field_label), 
                      y = !!sym(paste0(names_to_labels[numeric_field], " (mean)")))
          # End of plot 1
          ,
          data %>%
            # Rename the fields based on their field names
            transmute(
              "{category$field_label}" := category, 
              # Get the mean
              "{paste0(names_to_labels[numeric_field], \" (mean)\")}" := mean) %>%
          # Create a custom pie chart
          custom_pie(x = !!sym(category$field_label), 
                    y = !!sym(paste0(names_to_labels[numeric_field], " (mean)")),
                    title = paste0(names_to_labels[numeric_field], " (mean) per ", category$field_label))
        ,
        # Title for side by side plots
        title = paste0(names_to_labels[numeric_field], " (mean) per ", category$field_label)
        )
        
        # Side by side total bar chart and pie chart
        side_by_side(
          # Beginning of plot 2
          data %>%
            transmute(
              "{category$field_label}" := category, 
              # Get the sum (total)
              "{paste0(names_to_labels[numeric_field], \" (total)\")}" := sum) %>%
          # Create a custom bar plot
          custom_bars(x = !!sym(category$field_label), y = !!sym(paste0(names_to_labels[numeric_field], " (total)")))
          ,
          data %>%
            transmute(
              "{category$field_label}" := category, 
              # Get the sum (total)
              "{paste0(names_to_labels[numeric_field], \" (total)\")}" := sum) %>%
          # Create a custom bar plot
          custom_pie(x = !!sym(category$field_label), y = !!sym(paste0(names_to_labels[numeric_field], " (total)")),
          title = paste0(names_to_labels[numeric_field], " (total) per ", category$field_label))
        ,
        # Title for side by side plots
        title = paste0(names_to_labels[numeric_field], " (total) per ", category$field_label)
        )
        
        # Side by side min bar chart and pie chart
        side_by_side(
          data %>%
            # Rename the fields based on their field names
            transmute(
              "{category$field_label}" := category, 
              # Get the mean
              "{paste0(names_to_labels[numeric_field], \" (min)\")}" := min) %>%
          # Create a custom bar plot
          custom_bars(x = !!sym(category$field_label), 
                      y = !!sym(paste0(names_to_labels[numeric_field], " (min)")))
          # End of plot 1
          ,
          data %>%
            # Rename the fields based on their field names
            transmute(
              "{category$field_label}" := category, 
              # Get the mean
              "{paste0(names_to_labels[numeric_field], \" (min)\")}" := min) %>%
          # Create a custom bar plot
          custom_pie(x = !!sym(category$field_label), 
                      y = !!sym(paste0(names_to_labels[numeric_field], " (min)")),
          title = paste0(names_to_labels[numeric_field], " (min) per ", category$field_label))
        ,
        # Title for side by side plots
        title = paste0(names_to_labels[numeric_field], " (min) per ", category$field_label)
        )
        
        # Side by side max bar chart and pie chart
        side_by_side(
          data %>%
            transmute(
              "{category$field_label}" := category, 
              "{paste0(names_to_labels[numeric_field], \" (max)\")}" := max) %>%
          # Create a custom bar plot
          custom_bars(x = !!sym(category$field_label), y = !!sym(paste0(names_to_labels[numeric_field], " (max)")))
          # End of plot 1
          ,
          data %>%
            transmute(
              "{category$field_label}" := category, 
              "{paste0(names_to_labels[numeric_field], \" (max)\")}" := max) %>%
          # Create a custom bar plot
          custom_pie(x = !!sym(category$field_label), y = !!sym(paste0(names_to_labels[numeric_field], " (max)")),
          title = paste0(names_to_labels[numeric_field], " (max) per ", category$field_label))
        ,
        # Title for side by side plots
        title = paste0(names_to_labels[numeric_field], " (max) per ", category$field_label)
        )

      })
  }
}
```

### 

```{r stacked_bars, results='asis', message=FALSE}
# A "New names:" warning is introduced by the custom_crosstabs function
# TODO: Fix warning from custom_crosstabs

# If there are at least two categories
if (length(radio_categories) >= 2) {
  cat("<h3>Stacked and grouped bars</h3>")
  
  # Get the combination of these two categories
  radio_pairs <- combn(radio_categories, 2, simplify = FALSE)
  # For each pair of radio categories
  for (radio_pair in radio_pairs) {
    report_data %>%
      transmute(
        # Select the x and y categories
        across(all_of(radio_pair[[1]]$field_name), .names = "{radio_pair[[1]]$field_label}"),
        # Repeat for second column
        across(all_of(radio_pair[[2]]$field_name), .names = "{radio_pair[[2]]$field_label}")
      ) %>%
      # Group by both columns and do not drop levels where there are no matches
      group_by_all(.drop = FALSE) %>%
      # Get a count of each pair of levels
      summarise(count = n()) %>%
      # Ungroup data
      ungroup() %>%
      mutate(percent = count/sum(count)) %>%
      (function(data) {
        # Create a custom stacked  and a grouped bar plot 
        # with the first field as x and print them side by side
        side_by_side(
          # stacked bar plot
          data %>%
            custom_stacked(
              # x and y are the categories
              x = !!sym(radio_pair[[1]]$field_label), 
              y = !!sym(radio_pair[[2]]$field_label), 
              # fill is the data to fill the bars with
              fill = count, 
              title = paste0(radio_pair[[1]]$field_label, " and ", radio_pair[[2]]$field_label))
          ,
          data %>%
            custom_stacked(
              x = !!sym(radio_pair[[1]]$field_label), 
                           y = !!sym(radio_pair[[2]]$field_label), 
                           fill = count, 
                           title = paste0(radio_pair[[1]]$field_label, " and ", radio_pair[[2]]$field_label),
                           # position = dodge indicates grouped bar plot
                           position = "dodge",
                           max_bars = 17)
          ,
          # The title to include
          title = paste0(radio_pair[[1]]$field_label, " and ", radio_pair[[2]]$field_label)
        )
        
      # Create a two more custom stacked and a grouped bar plots 
      # with the first field as y and print and them side by side
        side_by_side(
          data %>%
          # Create a custom stacked bar plot with the data with the first field as y
            custom_stacked(
              x = !!sym(radio_pair[[2]]$field_label), 
              y = !!sym(radio_pair[[1]]$field_label), 
              fill = count, 
              title = paste0(radio_pair[[2]]$field_label, " and ", radio_pair[[1]]$field_label))
          ,
          data %>%
          custom_stacked(
              x = !!sym(radio_pair[[2]]$field_label), 
              y = !!sym(radio_pair[[1]]$field_label), 
              fill = count, 
              title = paste0(radio_pair[[2]]$field_label, " and ", radio_pair[[1]]$field_label),
              position = "dodge",
              max_bars = 17)
          ,
          title = paste0(radio_pair[[2]]$field_label, " and ", radio_pair[[1]]$field_label)
        )

      # Plot a custom crosstab for either direction of the categorical variables
        data %>%
          # Pass the data to the custom_crosstab function
          custom_crosstab(
            x = !!sym(radio_pair[[1]]$field_label),
            y = !!sym(radio_pair[[2]]$field_label),
            total = count) %>%
          print_table(paste0(radio_pair[[1]]$field_label, " vs ", radio_pair[[2]]$field_label, " (count)"))

        data %>%
          # Pass the data to the custom_crosstab function
          custom_crosstab(
            x = !!sym(radio_pair[[2]]$field_label),
            y = !!sym(radio_pair[[1]]$field_label),
            total = count) %>%
          print_table(paste0(radio_pair[[2]]$field_label, " vs ", radio_pair[[1]]$field_label, " (count)"))
      
        
        data %>%
          # Pass the data to the custom_crosstab function
          custom_crosstab(
            x = !!sym(radio_pair[[1]]$field_label),
            y = !!sym(radio_pair[[2]]$field_label),
            total = percent,
            percent = TRUE) %>%
          print_table(paste0(radio_pair[[1]]$field_label, " vs ", radio_pair[[2]]$field_label, " (percents of table total)"))

        data %>%
          # Pass the data to the custom_crosstab function with percents
          custom_crosstab(
            x = !!sym(radio_pair[[2]]$field_label),
            y = !!sym(radio_pair[[1]]$field_label),
            total = percent,
            percent = TRUE) %>%
          print_table(paste0(radio_pair[[2]]$field_label, " vs ", radio_pair[[1]]$field_label, " (percents of table total)"))
    })

  }
}

```

```{r maps}
# If a field_name contains one of these keywords it will be considered a longitude/latitude column
# ADD keywords in order of longest starting string to shortest
# e.g. c("longitude", "longitud", "long", "l")
longitude_keywords <- c("longitude", "longitud")
latitude_keywords <- c("latitude", "latitud")

# Create a dataframe of the field names containing the longitude keywords
longitudes <- data_dictionary %>%
  # Choose field_names that contain longitude keywords
  filter(field_name %in% names(report_data) 
         & grepl(paste0("*", longitude_keywords,"*", collapse = "|"), field_name) ) %>%
  transmute(
    # Include the field name
    field_name,
    # The field label
    field_label, 
    # The name with the latitude keyword removed
    stripped_name = sapply(regmatches(field_name, gregexpr(pattern = paste0(longitude_keywords, collapse = "|"), field_name), invert = TRUE), paste0, collapse = "", USE.NAMES = FALSE))

# Create a dataframe of the field names containing the latitude keywords
latitudes <- data_dictionary %>%
  filter(field_name %in% names(report_data)
         & grepl(paste0("*", latitude_keywords,"*", collapse = "|"), field_name)) %>%
  transmute(
    field_name, 
    field_label, 
    stripped_name = sapply(regmatches(field_name, gregexpr(pattern = paste0(latitude_keywords, collapse = "|"), field_name), invert = TRUE), paste0, collapse = "", USE.NAMES = FALSE))

# Join the latitude and longitude dataframes by the stripped names
# e.g. sending_longitude and sending_latidute => sending_
# so they share a row in the coordinates field dataframe
coordinate_fields <- inner_join(longitudes, latitudes, by = "stripped_name") 

# If there is more than one coordinate_field
if (nrow(coordinate_fields) > 0) {
  # Create a list of coordinate fields where each item has...
  coordinate_fields <- coordinate_fields %>%
  {mapply(FUN = function(longitude_name, latitude_name, longitude_label, latitude_label) {
    list(
      # The following attributes
      longitude_name = longitude_name,
      latitude_name = latitude_name,
      longitude_label = longitude_label,
      latitude_label =latitude_label
    )
  }, longitude_name = .[,"field_name.x"], latitude_name = .[,"field_name.y"], longitude_label = .[,"field_label.x"], latitude_label = .[,"field_label.y"], SIMPLIFY = FALSE)}
} else {
  coordinate_fields <- list()
}

if (length(coordinate_fields) > 0) {
    cat("<h3>Location counts</h3>")
# Create a list of maps by
maps <- list()

for (coordinate_field in coordinate_fields) {
  maps <- maps %>%
    append(
      report_data %>%
        # Naming them longitude and latitude respectively
        transmute(
          across(all_of(c(coordinate_field$longitude_name, coordinate_field$latitude_name)), .names = "{names_to_labels[.col]}")
        ) %>%
        # Remove na entries
        na.omit() %>%
        (function (data) {
          list(
            data%>%
             # group by pairs of longitudes and latitudes
              group_by(across(everything())) %>%
              # Add a location id to each latitude/longitude combination
              # and add a count for the number of entries per location
              summarise(location = cur_group_id(), count = n()) %>%
              # Ungroup the output
              ungroup() %>%
              # Create a custom map with each location having its own color
              custom_map(lng = coordinate_field$longitude_label, lat = coordinate_field$latitude_label, type = "location", count = "count"),
            # Create a custom map that clusters the locations
            data %>%
              # Create a custom map with each location having clusterings
              custom_map(lng = coordinate_field$longitude_label, lat = coordinate_field$latitude_label)
          )
        })
      )
                  
                  
                        
  
  if (!any(duplicated(report_data[, c(coordinate_field$longitude_name, coordinate_field$latitude_name)]))) {
    cat("<h5>Coordinates with category</h5>")
    
      maps <- maps %>%
        append(lapply(
          radio_categories,
          function(category) {
            report_data %>%
                    # Naming them longitude and latitude respectively
                    transmute(
                      across(all_of(c(coordinate_field$longitude_name, coordinate_field$latitude_name, category$field_name)), .names = "{names_to_labels[.col]}")
                    ) %>% mutate(count = 1) %>%
                    filter(!is.na(!!sym(coordinate_field$longitude_label)) & !is.na(!!sym(coordinate_field$latitude_label))) %>%
              custom_map(lng = coordinate_field$longitude_label, lat = coordinate_field$latitude_label, type = category$field_label)
          }))
  }
}
# Use htmltools to print the maps

htmltools::tagList(maps)
}
# if (length(coordinate_fields) >= 2) {
#   maps <- mapply(custom_network_map, combn(coordinate_fields, 2, simplify = FALSE), MoreArgs = list(data = report_data, both = TRUE), SIMPLIFY = FALSE)
#   htmltools::tagList(maps)
# } 
```

```{r network_graphs, out.width = "100%", fig.align="center"}
# Take the text fields from the data dictionary
text_fields <- data_dictionary %>%
  filter(field_type == "text" & field_name %in% names(report_data)) %>%
  # Create a list of field_names and field_labels
  {mapply(
    FUN = function(field_name, field_label) {
      list(
        field_name = field_name,
        field_label = field_label
      )
    }, .[["field_name"]], .[["field_label"]],
    SIMPLIFY = FALSE
  )}

# If there are 2 or more text fields
if (length(text_fields) > 1) {
  cat("<h3>Network graphs</h3>")
  
  # For each text pair
  for (text_pair in combn(text_fields, 2, simplify = FALSE)) {
    # If both of the columns aren't null
    if(!all(is.na(report_data[[text_pair[[1]]$field_name]]))
       && !all(is.na(report_data[[text_pair[[2]]$field_name]])))
      # Get the columns from the report data
      report_data %>%
              # Turn them into factors and add NA as a factor if there are any
              transmute(across(all_of(c(text_pair[[1]]$field_name, text_pair[[2]]$field_name)),
                        function(column) {
                          addNA(factor(column), ifany = TRUE)
                        }
                          , .names = "{names_to_labels[.col]}")
              ) %>%
              {side_by_side(
              custom_network(., x = !!sym(text_pair[[1]]$field_label), y = !!sym(text_pair[[2]]$field_label))
              ,
              plot2 = custom_network(., x = !!sym(text_pair[[2]]$field_label), y = !!sym(text_pair[[1]]$field_label))
              ,
              title = paste0(text_pair[[1]]$field_label, " vs ", text_pair[[2]]$field_label)
              )}
              
  }
}
```



