---
#authors: "Victor Espinosa, Alvaro Ciganda, Joel Cohen"
output: html_document

params:
  pid: 0
  reportId: 0
  server_url: ""
  token: ""
  dynamic_filter1: "Example1"
  dynamic_filter2: "Example2"
  dynamic_filter3: "Example3_dairy_complete"
  lf1: "1"
  lf2: "3"
  lf3: "2"
---

# Test


```{r setup, include=FALSE }
#knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(echo = FALSE)
# Used for data manipulation
#library(tidyr)
library(dplyr)
options(dplyr.summarise.inform = FALSE)
library(data.table)
  # Used to take permutations of fields
library(gtools)

# Used for connections
library(RCurl)
```

```{r data_processing_functions, results='asis'}
# title_caps
# Author: Joel Cohen (Based on previously existing work)
# Description:
# 
# Takes a character array or vector of character arrays of and transforms 
# capitalizes the first letter of each word.
# 
# e.g.
# Input:
#
# c("lorem ipsum dolor sit amet", "the quick brown dog jumped") 
#
# Returns:
#
# c("Lorem Ipsum Dolor Sit Amet", "The Quick Brown Dog Jumped")
title_caps <- function (string_vec) {
  string_vec <- if (typeof(string_vec) == "character") c(string_vec) else string_vec
  vapply(strsplit(string_vec, " "), FUN = function(x) {paste(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x)), collapse = " ", sep = "")}, FUN.VALUE = "")
}

# import_data
# Author: Joel Cohen (Based on previously existing work)
# Description:
# 
# Retrieves a REDCap report's data frame with live filters applied
# If no parameters are supplied, it uses local files for the data frames.
#
# Input:
#   params:
#     pid: 0
#     reportId: 0
#     server_url: ""
#     token: ""
#     dynamic_filter1: ""
#     dynamic_filter2: ""
#     dynamic_filter3: ""
#     lf1: ""
#     lf2: ""
#     lf3: ""
#
#   live_filters:
#     field_name <chr>    option_code <chr>     option_name <chr> field_title <chr>
#     ...........................................................................
#     field1  	                  1	              option2	           Field 1
#     field2  	                  3	              option1  	         Field 2
#     instrument_one_complete     2	              Complete	       Instrument One
#     ...........................................................................
#
# Returns:
# 
# A dataframe containing the report fields with any applicable live filter.
#
# NOTE: entry ID MUST be a field in the report for this to work!
# TODO: Make local files non-static
import_data <- function(parameters, record_id, live_filters) {
  # TODO: We could filter locally if we didn't have to worry abour fields that aren't in the report
  ##########################
  # REDCap Report
  ##########################
    report_data <- read.csv(text = postForm(
        uri=parameters$server_url,
        token=parameters$token,
        content='report',
        format='csv',
        report_id=parameters$reportId,
        rawOrLabel='raw',
        rawOrLabelHeaders='raw',
        exportCheckboxLabel='false',
        returnFormat='csv',
       .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
      ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
  
    
    # If there are no live_filters active, submit the report_data
    if (nrow(live_filters) == 0) return(report_data)
    
    # If live filters are selected but there are duplicate entries 
    # in the report column report data_frame, return null
    # live filter records must be merged on the entry ids
    if (anyDuplicated(report_data)) return(data.frame())
  
  # Create filter condition to send request to redcap.
  filter_condition <- paste("[", live_filters$field_name, "] = \"", live_filters$option_code, "\"" ,sep = "", collapse = " AND ")
  
  
  # Create the array of field names to be returned from redcap
  report_fields <- toString(names(report_data))
  
  # All records matching live filter
  live_filtered_records <- read.csv(text = postForm(
      uri=parameters$server_url,
      token=parameters$token,
      content='record',
      fields= report_fields,
      format='csv',
      filterLogic = filter_condition,
      rawOrLabel='raw',
      rawOrLabelHeaders='raw',
      exportCheckboxLabel='false',
      returnFormat='csv',
     .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
    ), header = TRUE, sep = ",", stringsAsFactors = FALSE)

  return(
    report_data %>%
      inner_join(live_filtered_records) # TODO: by = report_id - decide whether or not it should be joined just by the report_id field or to try to match across all fields
  )
}

# post_project_info
# Author: Joel Cohen
# Description:
# 
# Uses the relevant parameters to request a the project info from REDCap
# 
# Input: 
#   params:
#     pid: 0
#     reportId: 0
#     server_url: ""
#     token: ""
#     dynamic_filter1: ""
#     dynamic_filter2: ""
#     dynamic_filter3: ""
#     lf1: ""
#     lf2: ""
#     lf3: ""
#
# Returns:
#
#   REDCap project info
post_project_info <- function (parameters) {
  ##########################
  # Project Dataframe
  ##########################
  read.csv(text = postForm(
    uri= parameters$server_url,
    token= parameters$token,
    content='project',
    format='csv',
    returnFormat='csv',
    .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
  ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
}

# post_data_dictionary
# Author: Joel Cohen
# Description:
# 
# Uses the relevant parameters to 
# 
# Input: 
#   params:
#     pid: 0
#     reportId: 0
#     server_url: ""
#     token: ""
#     dynamic_filter1: ""
#     dynamic_filter2: ""
#     dynamic_filter3: ""
#     lf1: ""
#     lf2: ""
#     lf3: ""
#
# Returns:
#
#   A REDCap data dictionary
post_data_dictionary <- function (parameters) {
  ##########################
  # Data Dictionary
  ##########################
  # Reads a very large string for all dd from REDCap
  read.csv(text = postForm(
    uri=parameters$server_url,
    token= parameters$token,
    content='metadata',
    format='csv',
    returnFormat='csv',
   .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
  ), header = TRUE, sep = ",", stringsAsFactors = FALSE)
}

# parse_categories
# Author: Joel Cohen
# Description:
# 
# Takes a REDCap Data Dictionary and extracts the options for each categorical variable.
# 
# Input:
#
#   required: A REDCap Data Dictionary
# 
#   optional: A list of categorical variables
#             (Default):  "radio", "dropdown", "yesno", "truefalse", "checkbox"
#
# Returns:
#
#   A Nested list of the form:
#
#   $field_name1
#     $field_name1$code
#     [1] "1", "2", "3"
#
#     $field_name1$label
#     [1] "option1", "option2", "option3"
#
#   $field_name2
#     $field_name2$code
#     [1] "A", "B", "C"
#
#     $field_name2$label
#     [1] "optionA", "optionB", "optionC"
parse_categories <- function(data_dictionary, categoricals = c("radio", "dropdown", "yesno", "truefalse", "checkbox")) {
  categorical_indexes <- data_dictionary$field_type %in% categoricals
  
  # Create a list of categories and their options
  categories <- 
    # split the variables by | "The pipe character"
    strsplit(data_dictionary$select_choices_or_calculations[categorical_indexes], "[|]") %>% 
    # Strip white space on either end of the categories_list
    lapply(function (x) {gsub("^\\s+|\\s+$", "", x)}) %>% 
    # 
    lapply(function (x) {
      list(
        # Extract the code and remove leading and trailing whitespace
        code = gsub("^\\s+|\\s+$", "",substr(x, 1, regexpr(",", x)[1]-1)), 
        # Extract the label and remove leading and trailing whitespace
        label = gsub("^\\s+|\\s+$", "", substr(x, regexpr(",", x)[1]+1, nchar(x))) 
      )
    })
  
  # Assign each category the appropriate field name
  names(categories) <- data_dictionary$field_name[categorical_indexes] 

  return(categories) 
}

# parse_live_filters
# Author: Joel Cohen
# Description:
# 
# Creates a dataframe of the filter field, field_tile, option_code and option_label given 
# A categories list and parameters
#
# Input: 
#   parameters  - params:
#                   pid: 0
#                   reportId: 0
#                   server_url: ""
#                   token: ""
#                   dynamic_filter1: ""
#                   dynamic_filter2: ""
#                   dynamic_filter3: ""
#                   lf1: ""
#                   lf2: ""
#                   lf3: ""
#
#   categories  - A nested list of categorical fields and their options.
#
#   live_filter_status (Optional) - A named list mapping instrument filter codes to 
#                                   Incomplete, Unverified and Complete
# 
# Returns:
#
# A dataframe of the form:
#
#
# field_name <chr>    option_code <chr>     option_name <chr> field_title <chr>
# ...........................................................................
# field1  	                  1	              option2	           Field 1	
# field2  	                  3	              option1  	         Field 2	
# instrument_one_complete     2	              Complete	       Instrument One
# ...........................................................................
parse_live_filters <- function (parameters, categories, data_dictionary,live_filter_status = c("0" = "Incomplete","1"="Unverified","2" = "Complete")) {
  data.frame(field_name = c(params$dynamic_filter1, params$dynamic_filter2, params$dynamic_filter3), option_code = c(params$lf1, params$lf2, params$lf3)) %>%
  # Remove empty filters
  filter(option_code != "") %>%
  mutate(
     # Match the option_name to match to option_code from the instrument or categories list
     option_name = if_else( # Match titles for filters
        # If the field name ends in _complete
        substr(field_name, nchar(field_name)-8, nchar(field_name)) == "_complete", 
        # Let the label equal the corresponding status
        live_filter_status[option_code],
        # Otherwise...
        if_else( 
          # ... If the options code is equal to [NULL]
          option_code == "[NULL]",
          # Change it to an empty string (this is for the filter condition to send to REDCap)
          "",
          # In all other cases
          unlist(mapply(     
            # Attempt to map the option_name to the corresponding field_name, option_code in the categories list
            function(filter_name, code, options) {
              # If the code is in the corresponding field_name's options
              if (code %in% options[[filter_name]][["code"]]) 
                # Use the options label corresponding to that code
                options[[filter_name]][["label"]][which(code == options[[filter_name]][["code"]])] 
                # Otherwise, let it be empty
              else NA
            },
                field_name, option_code, MoreArgs = list(options = categories)
          ))
        )
     ),
    # Add a pretty field title
    field_title = if_else(
      # If the field_name ends in _complete
      substr(field_name, nchar(field_name)-8, nchar(field_name)) == "_complete",
      # Remove _complete, split it over underscores, and capitalize the first letter of each word\
      # e.g. Example_instrument_complete => Example Instrument
      gsub("_", " ", substr(field_name, 0, nchar(field_name)-9)) %>% title_caps(),
       # Otherwise try to match it with field label from the data_dictionary
      right_join(data_dictionary, data.frame(field_name = field_name), by = "field_name")[["field_label"]]
    )
  )
} 
```

```{r data_input}
# Get report metadata
project_info <- post_project_info(params)
data_dictionary <- post_data_dictionary(params)

# Get a list of categories and their options
categories <- parse_categories(data_dictionary)

# Retrieve the live filters
live_filters <- parse_live_filters(params, categories, data_dictionary)

# Retrieve report data
report_data <- import_data(params, data_dictionary$field_name[1], live_filters)
```

## Advanced Graphs 

### `r project_info$project_title`
#### project pid `r params$pid`
#### Number of results returned: `r nrow(report_data)`
##### Live filter(s)
###### `r paste0(live_filters$field_title, " = ", live_filters$option_name, collapse = "\n")`
<!--TODO: fix '=' when no live filters selected -->
```{r}
# TODO: Delete
# print(project_info)
#print(data_dictionary)
# print(categories)
# print(live_filters)
# print(report_data)
```


```{r likert_plots}
# Get categorical fields that can be made into likert graphs
likert_categories <- data_dictionary[data_dictionary$field_type %in% c("dropdown", "radio") & data_dictionary$field_name %in% names(report_data), "field_name"]

# TODO: Other checks such as making sure common categories share an instrument

# Get the levels for each categorical field
likert_candidate_levels <- lapply(likert_categories, function(x) {categories[[x]][["code"]]})
likert_candidate_labels <- lapply(likert_categories, function(x) {categories[[x]][["label"]]})

# Create a dataframe for each grouping of categorical variables
likert_groups <- data.table(likert_candidate_levels, likert_candidate_labels) %>%
  group_by(likert_candidate_levels, likert_candidate_labels) %>%
  summarise(indices = list(cur_group_rows()), category_names = list(likert_categories[cur_group_rows()]))

# TODO: delete
# print(likert_categories)
# print(likert_candidate_levels)
# print(likert_groups)

for (group_index in 1:nrow(likert_groups)) {
  # Get raw data and check for NA's
  raw_group_data <- as.data.frame(report_data[, unlist(likert_groups$category_names[group_index])])

  names(raw_group_data) <- likert_groups$category_names[group_index]

  # If there are any NA's
  if (any(is.na(raw_group_data))) {
    # Replace them with character vectors "NA"
    raw_group_data <- raw_group_data %>%
      replace(is.na(.), "NA")

    # Add an "NA" level
    likert_groups$likert_candidate_levels[[group_index]] <- append(likert_groups$likert_candidate_levels[[group_index]], "NA")

    # As well as a corresponding NA label
    likert_groups$likert_candidate_labels[[group_index]] <- append(likert_groups$likert_candidate_labels[[group_index]], "NA")
  }

  # Create a dataframe out of corresponding factors for each group
  likert_group_df <- data.frame(lapply(raw_group_data, factor, levels = likert_groups$likert_candidate_levels[[group_index]], labels = likert_groups$likert_candidate_labels[[group_index]]))

  # Print a likert bar plot for this group
  print(likert::likert.bar.plot(likert::likert(likert_group_df),
          as.percent = TRUE,
          horizontal=TRUE,
          xlimEqualLeftRight=FALSE,
          xTickLabelsPositive=TRUE,
          reverse=FALSE,
          xlab = "Percent",
          ylab.right = ""),
        height=1,
        wide=2,
        nlevels=6)
}
```

```{r scatter_plots}
# Take report data
numerical_data_fields <- report_data %>%
  # Select only numeric columns
  select(is.numeric) %>%
  # Only get field names
  names()

# TODO: Should we use combinations instead? Should we create our own permutations function to replace gtools?
numeric_pairs <- permutations(length(numerical_data_fields), 2, numerical_data_fields) 


empty <- apply(numeric_pairs, 1, function(name) {report_data %>% select(name) %>% na.omit() %>% plot})

```


