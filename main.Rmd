---
#authors: "Victor Espinosa, Alvaro Ciganda, Joel Cohen"
output: html_document

params:
  pid: 0
  reportId: 0
  server_url: ""
  token: ""
  dynamic_filter1: ""
  dynamic_filter2: ""
  dynamic_filter3: ""
  lf1: ""
  lf2: ""
  lf3: ""
---

# Test


```{r setup, include=FALSE }
#knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(echo = FALSE)


# Used for connections
library(RCurl)

# --- Used for creating plots ---
# Used for many nice looking plots
library(ggplot2)

# Used for likert plots
library(likert)

# Used to get good color palettes
library(RColorBrewer)
getPalette = colorRampPalette(brewer.pal(8, "Set2"))
library(viridis)

# Used for tables
library(kableExtra)

# Necessary for all percents in likert plot
library(plyr, include.only = c("ddply", "."))

# Used to create maps
library(leaflet)

# Used to create network graphs
library(igraph)

# Used to extract trailing numbers from checkboxes
library(stringr)

# -------------------------------

# --- Used for data manipulation ---
library(dplyr)
library(tidyr)
options(dplyr.summarise.inform = FALSE)

# Used to create dataframe with category lists for likert
# library(data.table, exclude = c("hour", "isoweek", "mday", "minute", "month", "quarter", "second", "wday", "week", "yday", "year"))
# ----------------------------------
```

```{r data_processing_functions, results='asis'}
source("./data_manipulation.R")

```

```{r custom_plots}
source("./custom_plots.R")
```


```{r data_input}
# TODO: The if statement is temporary and allows for testing on sample data
if (params$pid != 0) {
  # Get report metadata
  project_info <- post_project_info(params)
  data_dictionary <- post_data_dictionary(params)
  
  # Get a list of categories and their options
  categories <- parse_categories(data_dictionary)
  
  # Retrieve the live filters
  live_filters <- parse_live_filters(params, categories, data_dictionary)
  
  # Retrieve report data
  report_data <- import_data(params, data_dictionary$field_name[1], live_filters)
} else {
  # Data dictionary is same one from Advanced Graphs - Demo Project
  data_dictionary <- read.csv(file = "./sample/sample_data_dictionary.csv", header = TRUE)
  categories <- parse_categories(data_dictionary)
  
  project_info <- data.frame(project_title = c("Sample Data"))
  
  live_filters <- data.frame(c())
  
  # Report data was randomly sampled from Advanced Graphs - Demo Project
  report_data <- read.csv(file = "./sample/sample_report_data.csv", header = TRUE)
}
# Create list of labels
names_to_labels <- data_dictionary$field_label
names(names_to_labels) <- data_dictionary$field_name
```

## Advanced Graphs 

### `r project_info$project_title`
#### project pid `r params$pid`
#### Number of results returned: `r nrow(report_data)`
##### Live filter(s)
###### `r if (nrow(live_filters) > 0) paste0(live_filters$field_title, " = ", live_filters$option_name, collapse = "\n")`
<!--TODO: fix '=' when no live filters selected -->
```{r}
# TODO: Delete
# print(project_info)
#print(data_dictionary)
# print(categories)
# print(live_filters)
# print(report_data)
```


```{r likert_plots}
# Likert types
like_likert <- c("dropdown", "radio")
key_likert_words <- c("not useful", "not at all useful", "difficult", "none of my needs", "strongly disagree", "somewhat disagree", "completely disagree", "quite dissatisfied", "very dissatisfied", "Extremely dissatisfied", "poor", "never", "worse", "severely ill", "inutil", "in\u00fatil", "completamente inutil", "completamente in\u00fatil", "dificil", "dif\u00edcil", "ninguna de mis necesidades", "totalmente en desacuerdo", "parcialemnte en desacuerdo", "completamente en desacuerdo", "muy insatisfecho(a)", "totalmente insatisfecho(a)", "nunca", "peor", "gravemente enfermo")

# From the data dictionary
likert_groups <- data_dictionary %>%
  filter(
    # Select only the fields that are in the report
    field_name %in% names(report_data) 
    # That have a field type that can be likert
    & field_type %in% like_likert
    # And whose options contain a likert keyword
    & grepl(paste0("*",tolower(key_likert_words), "*", collapse = "|"), tolower(select_choices_or_calculations))
  ) %>%
  # Group the fields that have the same options
  group_by(select_choices_or_calculations) %>%
  # Take a list of field names and labels
  summarise(field_name = list(field_name), field_label = list(field_label)) %>%
  # Parse the categories into a useful format
  parse_categories()

# For each set of fields that share options
for (likert_group in likert_groups) {
    report_data %>%
      # Select these fields from the data dictionary and turn them into factors
      transmute(across(all_of(likert_group$field_name), factor, levels = likert_group$options_code, labels = likert_group$options_label, .names = "{likert_group$field_label}")) %>%
      (function(data) {
        # If any of the fields contain an NA
       if (any(is.na(data))) { 
         return(
           # Add an NA field to each factor
           transmute(data, across(.fns = addNA)) 
         )
       } 
        # Otherwise return the data as is
        return(data) 
      }) %>%
      # Pass this dataframe to the custom likert
      custom_likert() %>%
      # print this plot
      print()
}
```

```{r scatter_plots}
# Fields to ignore if any of these words appear anywhere in the field name
ignored_names = c("latitude", "longitude", "latitud", "longitud")

accepted_text_validation = c("integer", "number", "float", "decimal")

# Get numerical fields
numerical_data_fields <- data_dictionary %>%
  filter(
    # The field name is in the report
    field_name %in% names(report_data)
    # The field type isn't null
    & !is.na(field_type) 
    # If the field type is text but there is no text validation, don't include (text field)
    & !(field_type == "text" & is.na(text_validation_type_or_show_slider_number)) 
    # Include only fields where either:
    & (
      # The field type is calc
      field_type == "calc" 
      # If the field type is text it uses a recognized validation format
      | (field_type == "text" 
          & grepl(paste0("*",accepted_text_validation, "*", collapse = "|"), text_validation_type_or_show_slider_number))
      )
      # And is not one of the ignored_names
    & !grepl(paste0("*", ignored_names, "*", collapse = "|"), field_name)
  ) %>%
  select(field_name) %>%
  unlist()

for (x_field in numerical_data_fields) {
  # And each field considered y
  for (y_field in numerical_data_fields) {
    # Excluding field_x = field_y
    if (y_field != x_field)
      custom_scatter(report_data[, c(x_field, y_field)], names_to_labels[c(x_field, y_field)])
  } 
}

# Get date fields
date_data_fields <- data_dictionary %>%
  # Select only fields in the report
  filter(field_name %in% names(report_data)
         # Select only fields that start with 'date'
         & substr(text_validation_type_or_show_slider_number, 1, 4) == "date") %>%
  # Select the field name
  select(field_name) %>%
  # Return field names in vector
  unlist()

# For each date_field (x in date - date plots)
for (date_field_x in date_data_fields) {
  # And numeric_field
  for (numeric_field in numerical_data_fields) {
      # Plot date as x and numeric as y
      custom_scatter(report_data[,c(date_field_x, numeric_field)], names_to_labels[c(date_field_x, numeric_field)], date_fields = date_field_x)
      # Plot numeric as x and date as y
      custom_scatter(report_data[,c(numeric_field, date_field_x)], names_to_labels[c(numeric_field, date_field_x)], date_fields = date_field_x)
  }
  
  # For each date_field
  for (date_field_y in date_data_fields) {
    # If the x date field and y date field are different
    if (date_field_x != date_field_y){
      # Create a custom scatter plot with the two date fields
      custom_scatter(report_data[,c(date_field_x, date_field_y)], names_to_labels[c(date_field_x, date_field_y)], date_fields = c(date_field_x, date_field_y))
    }
  }
}

```

```{r bar_plots}
# Get a parsed list of each checkbox field
checkbox_fields <- data_dictionary %>%
  filter(field_type == "checkbox") %>%
  parse_categories()

for (checkbox_field in checkbox_fields) {
  # If there is at least on field of the form "field_name___[0-9]+" in the report_data
  # create a plot
  if (any(grepl(paste0(checkbox_field$field_name, "___[0-9]+\\b"), names(report_data)))) {
    checkbox_plot <- report_data %>%
      # Select each column of the report data that matches the current checkbox field
      select(matches(paste0(checkbox_field$field_name, "___[0-9]+\\b"))) %>%
      # Let each column be it's own level in a factor column
      pivot_longer(cols = everything())  %>%
      # remove NA entries
      na.omit() %>%
      group_by(name, .drop = FALSE) %>%
      # Get the count and proportion for each of the checkboxes
      summarise(count = sum(value), percent = count/n())  %>%
      # Use the field label as the name 
      transmute(
        # Use the field_label as the name for the options
        "{checkbox_field$field_label}" := 
          # replace the field_name__1 with the corresponding label
          factor(checkbox_field$options_label[str_extract(name, "[0-9]+\\b")], levels = checkbox_field$options_label), 
        # Include counts and percents
        count, 
        percent) %>%
      # Create a custom bar plot
      custom_bars(x = !!sym(checkbox_field$field_label), y = count, label2 = percent, percent = TRUE) %>% print()
  }
}

# Radio or dropdown fields
radio_categories <- data_dictionary %>%
  # Select fields from the data dictionary
  filter(
    # Where they are of "radio" type
    field_type %in% c("radio", "dropdown", "yesno", "truefalse")
    # The field name is in the report data
    & field_name %in% names(report_data)
    # And there are options
    & select_choices_or_calculations != "") %>%
  # Turn them into a list of category attributes
  parse_categories()

for (radio_category in radio_categories) {
  # If the entire column isn't NA
  if (!all(is.na(report_data[[radio_category$field_name]])))
  report_data %>%
    transmute(
      # Select the column
      across(all_of(radio_category$field_name), 
             # Turn it into a factor
             function(column) {
               # add an NA level if there are NA's in the column
               addNA(factor(as.character(column), 
                            levels = radio_category$options_code, 
                            labels = radio_category$options_label), ifany=TRUE)
             },
             # Rename it the field label
             .names = radio_category$field_label)
      ) %>%
    # Get a count of each category
    group_by_all(.drop = FALSE) %>%
    summarise(count = n()) %>%
    mutate(percent = count/sum(count)) %>%
    # Create a custom bar plot
    custom_bars(x = !!sym(radio_category$field_label), y = count, label2 = percent, percent = TRUE) %>%
    # Print it
    print()
}

```

```{r numerical_bar_plots}
# For each radio category
for (category in radio_categories) {
  # If the category column isn't empty
  if (!all(is.na(report_data[[category$field_name]])))
  # For each numeric field
  for (numeric_field in numerical_data_fields) {
    # If the numeric column isn't empty
    if (!all(is.na(report_data[[numeric_field]])))
    report_data %>%
      transmute(
        # Turn radio category into factor
        across(all_of(category$field_name),
               function(column) {
                # add NA level if there are NAs present
                addNA(factor(column, 
                             levels = category$options_code, 
                             labels =  category$options_label), ifany = TRUE) 
               }, .names = "category"),
        # Select the numeric column
        across(all_of(numeric_field), .names = "numeric")
      ) %>% 
      # Remove entries where the numeric column is NA
      filter(!is.na(numeric)) %>% #print()
      # Group by the category and do not drop categories that do no show up in the data
      # TODO: Is this the behavior we want
      group_by(category, .drop = FALSE) %>%
      # Get the mean for each group, 0 if there are no numeric fields
      summarise(count = n(), mean = round(sum(numeric)/(if (count > 0) count else 1), 1)) %>%
      # Rename the columns by their respective field labels
      transmute("{category$field_label}" := category, "{paste0(names_to_labels[numeric_field], \" (mean)\")}" := mean) %>%
      # Create a custom bar plot
      custom_bars(x = !!sym(category$field_label), y = !!sym(paste0(names_to_labels[numeric_field], " (mean)"))) %>%
      # Print it
      print()
  }
}
```

```{r stacked_bars, results='asis'}
# For each pair of categories
for (category_x in radio_categories) {
  for (category_y in radio_categories) {
    # If the categories aren't the same
    if (category_x$field_name != category_y$field_name)
    report_data %>%
      transmute(
        # Turn both factors into columns
        across(c(category_x$field_name), 
                 function(column) {
                   # Adding NA as a factor if there are any NAs
                   addNA(factor(column,
                                # Using the option codes as the levels
                                levels = category_x$options_code, 
                                # Matching them to the labels and repairing empty or duplicate names
                                labels = category_x$options_label), ifany = TRUE)
                 },
               .names = "x_col"
        ),
        # Repeat for second column
        across(c(category_y$field_name), 
                 function(column) {
                   addNA(factor(column, 
                                levels = category_y$options_code, 
                                labels = category_y$options_label), 
                         ifany = TRUE)
                 },
               .names = "y_col"
        )
      ) %>%
      # Group by both columns and do not drop levels where there are no matches
      group_by(x_col, y_col, .drop = FALSE) %>%
      # Get a count of each pair of levels
      summarise(count = n()) %>%
      # Ungroup the data to avoid warning from transmute
      ungroup() %>%
      # Rename the columns to match the field labels
      transmute("{category_x$field_label}" := x_col,
                "{category_y$field_label}" := y_col,
                count) %>%
      (function(data) {
      data %>%
      # Create a custom stacked bar plot with the data
        custom_stacked(x = !!sym(category_x$field_label), y = !!sym(category_y$field_label), fill = count, title = paste0(category_x$field_label, " and ", category_y$field_label)) %>%
        print()
      

      # data %>%
      #   # Create a contingency table from the data
      #   pivot_wider(names_from = all_of(category_y$field_label), values_from = count, names_repair = "unique") %>%
      #   # Pass it to the custom crosstab function
      #   custom_crosstab(column_spanner = category_y$field_label) %>%
      #   # Print the custom crosstab
      #   print()
      })
  }
}
```


```{r maps, message=FALSE, out.width = "100%", fig.align="center", fig.height=8, fig.width=10}
# If a field_name contains one of these keywords it will be considered a longitude/latitude column
# ADD keywords in order of longest starting string to shortest
# e.g. c("longitude", "longitud", "long", "l")
longitude_keywords <- c("longitude", "longitud")
latitude_keywords <- c("latitude", "latitud")

longitudes <- data_dictionary %>%
  # Choose field_names that contain longitude keywords
  filter(field_name %in% names(report_data) 
         & grepl(paste0("*", longitude_keywords,"*", collapse = "|"), field_name) ) %>%
  transmute(
    # Include the field name
    field_name,
    # The field label
    field_label, 
    # The name with the latitude keyword removed
    stripped_name = sapply(regmatches(field_name, gregexpr(pattern = paste0(longitude_keywords, collapse = "|"), field_name), invert = TRUE), paste0, collapse = "", USE.NAMES = FALSE))

# Repeat for latitude keywords
latitudes <- data_dictionary %>%
  filter(field_name %in% names(report_data)
         & grepl(paste0("*", latitude_keywords,"*", collapse = "|"), field_name)) %>%
  transmute(
    field_name, 
    field_label, 
    stripped_name = sapply(regmatches(field_name, gregexpr(pattern = paste0(latitude_keywords, collapse = "|"), field_name), invert = TRUE), paste0, collapse = "", USE.NAMES = FALSE))

# Join the latitude and longitude dataframes by the stripped names
coordinate_fields <- inner_join(longitudes, latitudes, by = "stripped_name") %>%
  # For each stripped name (e.g. sending_) 
  # names and labels for the latitudea nd longitude column
  {mapply(FUN = function(longitude_name, latitude_name, longitude_label, latitude_label) {
    list(
      longitude_name = longitude_name,
      latitude_name = latitude_name,
      longitude_label = longitude_label,
      latitude_label =latitude_label
    )
  }, longitude_name = .[,"field_name.x"], latitude_name = .[,"field_name.y"], longitude_label = .[,"field_label.x"], latitude_label = .[,"field_label.y"], SIMPLIFY = FALSE)}

# Create a list of maps by
maps <- lapply(coordinate_fields,
              function(coordinate_field) {
                # Taking the corespinding latitude and longitude columns from the report data
                report_data %>%
                  # Nameing them longitude and latitude respectively
                  transmute(
                    across(all_of(coordinate_field$longitude_name), .names = "longitude"),
                    across(all_of(coordinate_field$latitude_name), .names = "latitude")
                  ) %>%
                  # Remove na entries
                  na.omit() %>%
                  # Get a column counting each longitude and latitude
                  group_by_all() %>%
                  summarise(count = n()) %>%
                  # Send it to our map function
                  custom_map(title = paste0(coordinate_field$longitude_label, " vs ", coordinate_field$latitude_label))
              }
)

# Use taglist to create a list of maps that can be displayed
htmltools::tagList(maps)
```

```{r network_graphs, out.width = "100%", fig.align="center"}
# Take the text fields from the data dictionary
text_fields <- data_dictionary %>%
  filter(field_type == "text" & field_name %in% names(report_data)) %>%
  # Create a list of field_names and field_labels
  {mapply(
    FUN = function(field_name, field_label) {
      list(
        field_name = field_name,
        field_label = field_label
      )
    }, .[["field_name"]], .[["field_label"]],
    SIMPLIFY = FALSE
  )}

# If there are 2 or more text fields
if (length(text_fields) > 1)
# For each text pair
for (text_pair in combn(text_fields, 2, simplify = FALSE)) {
  # If both of the columns aren't null
  if(!all(is.na(report_data[[text_pair[[1]]$field_name]]))
     && !all(is.na(report_data[[text_pair[[2]]$field_name]])))
    # Get the columns from the report data
    report_data %>%
            # Turn them into factors and add NA as a factor if there are any
            transmute(across(all_of(c(text_pair[[1]]$field_name, text_pair[[2]]$field_name)),
                      function(column) {
                        addNA(factor(column), ifany = TRUE)
                      }
                        , .names = "{names_to_labels[.col]}")
            ) %>%
            # Create a graph from the data
            graph_from_data_frame(directed = TRUE) %>%
            # Plot it
            plot(edge.width = 2,
           main = paste0(text_pair[[1]]$field_label, " vs. " ,text_pair[[2]]$field_label),
           cex.main = 100,
           sub = "",
           edge.arrow.width = 0.3,
           vertex.size = 3,
           edge.arrow.size = 0.5,
           vertex.size2 = 3,
           vertex.label.cex = .75,
           asp = .65,
           margin = -0.1)
}
```



