---
  #title: "network_graphs"
  #author: "Victor Espinosa and Alvaro Ciganda"
  #version: 1.0.0
  #date: "10/07/2020"
output: html_document

params:
  pid: 0
  reportId: 0
  server_url: ""
  token: ""
  dynamic_filter1: ""
  dynamic_filter2: ""
  dynamic_filter3: ""
  lf1: ""
  lf2: ""
  lf3: ""

---

```{r setup, include=FALSE }

library(stringr) # to manipulate strings

# Used for connections
library(RCurl)

# Used in network graphs
library(igraph)

##########################
# Function to break a phrase in different lines of size close to row_len

remove_html <- function(label_in) {
  label_out <- str_remove_all(label_in, "<.*?>")
  return(label_out)
  #return(gsub("<.*?>", "", label_in))
}

##########################
# Initial values
##########################
# HARD CODED FOR TESTING PURPOSES (ALSO REPORT ID AND TOKEN)
 server_url <- 'http://10.124.163.238/redcap/api/'
#server_url <- params$server_url

initial_point_size <- 0.7
increase_point_size <- 0.1

#report_number <- params$reportId
report_number <- 739

##########################
# Project Title
##########################

project_info <- postForm(
  uri= server_url,
  # token= params$token,
  token= "5E8F92FC99077838B3CA0B21E277FB57",
  content='project',
  format='csv',
  returnFormat='csv',
  .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
  
)

project_df <- read.csv(text = project_info, header = TRUE, sep = ",", stringsAsFactors = FALSE)           # read project info in csv format


##########################
# Data Dictionary
##########################

# Reads a very large string for all dd from REDCap
dd <- postForm(
  uri=server_url,
  #token= params$token,
  token= "5E8F92FC99077838B3CA0B21E277FB57",
  content='metadata',
  format='csv',
  returnFormat='csv',
  .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
)

dd_df <- read.csv(text = dd, header = TRUE, sep = ",", stringsAsFactors = FALSE)

# # Breaks dd by field in a vector of single, long strings for each field
# dd_table <- unlist(strsplit(dd, split="\n"))
dd_len   <- nrow(dd_df)

# Creates empty vectors for each dd component and each field
field_name_dd <- character(length = dd_len)
field_type_dd <- character(length = dd_len)
field_label_dd <- character(length = dd_len)
text_val_dd <- character(length = dd_len)
choices_calc_dd <- character(length = dd_len)
options_label <- matrix(character(), dd_len, 999)
options_label_short <- matrix(character(), dd_len, 999)
options_value <- matrix(numeric(), dd_len, 999)
options_number <- character(length =  dd_len)
branching_dd <- character(length = dd_len)
# form_name_dd <- character(length = dd_len)
# section_header_dd <- character(length = dd_len)
# fields_other_dd <- character(length = dd_len)


# # To read the dd in a line! From Alvaro Ciganda; check last two parameters
# df_api<-read.table(text = dd, sep =",", header = TRUE, stringsAsFactors = FALSE, as.is = TRUE)

field_name_dd     <- dd_df$field_name
field_type_dd     <- dd_df$field_type
field_label_dd    <- dd_df$field_label
choices_calc_dd   <- dd_df$select_choices_or_calculations
text_val_dd       <- dd_df$text_validation_type_or_show_slider_number
choices_calc_len <- length(choices_calc_dd)
branching_dd   <- dd_df$branching_logic
# form_name_dd      <- dd_df$form_name
# section_header_dd <- dd_df$section_header
# Loop over all fields with options to extract its components
for(var_dd in 1:dd_len) {
  # If they have non-empty choices and are radio or drop-down lists or checkboxes
  if( !is.na(choices_calc_dd[var_dd]) && 
      (field_type_dd[var_dd] == "radio" || field_type_dd[var_dd] =="dropdown" || field_type_dd[var_dd] == "checkbox") ) {
    # Removes leading characters and breaks components separated by | into a list
    # 'gsub' replaces all matches of a string
    # 'unlist' breaks a string
    aux <- data.frame( x = gsub("^\\s+|\\s+$", "",unlist(strsplit(choices_calc_dd[var_dd],"|",fixed=TRUE)))   )
    # 'separate' splits code from label for each option with only the first comma as separator (extra commas are ignored and the rest of the text is merged into the label)
    aux_options <- aux %>% separate(x, c("code", "label"), sep = ",", extra = "merge")
    # To remove leading space
    aux_options$label <- gsub("^\\s", "", aux_options$label)
    if(!is.na(aux_options$label[1]) || !is.na(aux_options$label[2]) || !is.na(aux_options$label[3])) {
      options_label[var_dd,1:length(aux_options$label)] <- aux_options$label
      options_value[var_dd,1:length(aux_options$label)] <- aux_options$code
      options_number[var_dd] <- length(aux_options$label)
    }
  }
}

```


```{r data_preparation, include=FALSE }

#########################
# Data Preparation
#########################

# Preparing message in case there are no graphs displayed
printed_graphs <- FALSE
no_graphs <- ""

# Preparing message in case there are no data retrieved
no_results <- ''

# Reading report from REDCap
data_report <- postForm(
  uri=server_url,
  #token=params$token,
  token= "5E8F92FC99077838B3CA0B21E277FB57",
  content='report',
  format='csv',
  report_id=report_number,
  rawOrLabel='raw',
  rawOrLabelHeaders='raw',
  exportCheckboxLabel='false',
  returnFormat='csv',
  .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
)

report_cols_len <- 0
col_names_report <- ''
data_report_matrix <- read.csv(text = data_report, header = TRUE, sep = ",", stringsAsFactors = FALSE)
data_report_size = nrow(data_report_matrix)

data_report_df <- data.frame(data_report_matrix)
col_names_report_df <- colnames(data_report_df)

#### field_name_dd[3:12] `r field_name_dd[3:12]`
#### field_type_dd[3:12] `r field_type_dd[3:12]`
#### field_label_dd `r field_label_dd[3]`
#### choices_calc_dd `r choices_calc_dd[3]`
#### text_val_dd `r text_val_dd[3]`

```

```{r filters, include=FALSE }

##############################
# Live filters implementation
##############################

live_filter <- c(params$dynamic_filter1, params$dynamic_filter2, params$dynamic_filter3)
live_filter_value <- c(params$lf1, params$lf2, params$lf3)


live_filter_num <- length(live_filter)
filter_title <- c('', '', '')
filter_value <- c('', '', '')

filters_title <- ''

# Replace selected filter fields by their labels and option names from dd 
# For all filters  
for(i in 1:live_filter_num) {
  # if live filter is on complete flag for an instrument and it's used
  if(substr(live_filter[i], nchar(live_filter[i])-8, nchar(live_filter[i])) == '_complete' & live_filter_value[i] != "" ) {
    filter_title[i] <- substr(live_filter[i], 0, nchar(live_filter[i])-9)
    # Make form name nicer
    filter_title[i] <- paste(capitalize(str_replace(filter_title[i], '_', ' ')), "instrument", sep = ' ')
    if(live_filter_value[i] == 2) filter_value[i] <- 'Complete'
    else if(live_filter_value[i] == 1) filter_value[i] <- 'Unverified'
    else if(live_filter_value[i] == 0) filter_value[i] <- 'Incomplete'
  }
  else {
    # loop for all fields in dd
    for(j in 1:dd_len) {
      if(live_filter_value[i] != "" & live_filter[i] == field_name_dd[j]) {
        filter_title[i] <- field_label_dd[j]
        
        # Assigns 'blank value' label if empty value is selected
        if(live_filter_value[i] == "[NULL]" ) filter_value[i] <- "(blank value)"
        else {
          if(!isTRUE(options_number[j] == "") ) { 
            for(k in 1:options_number[j]) {
              # Selects the corresponding option label to the option value selected
              if(options_value[j, k] == live_filter_value[i]) filter_value[i] <- options_label[j, k] # removed as.numeric from live_filter_value because codes are not necessarily numbers
            }
          }
        }
        # break # Can I use this instruction to break the loop in all fields in dd?
      }
    }
  } 
}

# Put together the filters title
for(i in 1:live_filter_num) {
  if(live_filter_value[i] != "" ) {
    filter_title[i] <- paste(filter_title[i], filter_value[i], sep = ' = ' )
    filters_title <- 'live filter(s):'
  }
}
```

```{r filtering data, include=FALSE }

##################
# Filtering data
##################

col_names_report_mat <- colnames(data_report_df)
col_pos <- c(0,0,0)
# Identifying report columns corresponding to live filters
for(cont in 1:ncol(data_report_df)) {
  for(i in 1:live_filter_num) {
    if(live_filter_value[i] != "" && col_names_report_df[cont]== live_filter[i]) col_pos[i] <- cont
  }
}

for(i in 1:live_filter_num) {
  # Subsetting report data according to true live filter values
  if(live_filter_value[i] != "" & live_filter_value[i] != "[NULL]" & col_pos[1] > 0) 
    data_report_matrix <- data_report_matrix[data_report_matrix[, col_pos[i]] == live_filter_value[i], ]
  # Subsetting report data according to live filter values when "(blank value)" has been selected
  if(live_filter_value[i] == "[NULL]" & col_pos[1] > 0) data_report_matrix <- data_report_matrix[  is.na(data_report_matrix[, col_pos[1]]), ]
}

# Set filter expressions for live filters 
filter_condition <- ""


### Create lcondition for any combination in each live filter
for(i in 1:live_filter_num) {
  # If live filter has been selected 
  if(live_filter_value[i] != "" ) {
    ## case when previous live filters were selected, adding AND connector
    if(filter_condition != "") {
      filter_condition <- paste(filter_condition, ' AND ', sep = '')
    }
    # case when filter has been selected to non-blank value
    if(live_filter_value[i] != "[NULL]" ) filter_condition <- paste(filter_condition, '[' , live_filter[i] , '] = "' ,  live_filter_value[i], '"', sep = '')
    # case when filter has been selected to blank value
    else filter_condition <- paste(filter_condition, '[' , live_filter[i] , "] = ''" , sep = '')
  }
}


no_record_id_n_filter <- ""

# if record id is in the report and filters are used, it proceed to get the list of records fulfilling the criteria
if(field_name_dd[1]%in% names(data_report_matrix) && filter_condition != "" ) {
  # Reading list of filtered records from REDCap
  data_filter <- postForm(
    uri=server_url,
    #token=params$token,
    token= "5E8F92FC99077838B3CA0B21E277FB57",
    content='record',
    fields=field_name_dd[1],
    format='csv',
    filterLogic = filter_condition,
    rawOrLabel='raw',
    rawOrLabelHeaders='raw',
    exportCheckboxLabel='false',
    returnFormat='csv',
    .opts = RCurl::curlOptions(ssl.verifypeer = FALSE, ssl.verifyhost = FALSE, verbose=FALSE)
  )
  
  
  data_filter_matrix <- NULL
  try(data_filter_matrix <- read.csv(text = data_filter, header = TRUE, sep = ",", stringsAsFactors = FALSE), silent = TRUE)
  
  # Matches the records in the report with the ones in the list of filtered ones
  data_report_matrix <- merge(data_report_matrix, data_filter_matrix, by= intersect(names(data_report_matrix), names(data_filter_matrix)), all = FALSE)
  
  if("redcap_repeat_instrument.y"%in% names(data_report_matrix) ) {
    data_report_matrix <- subset(data_report_matrix, select= -c(redcap_repeat_instrument.y) ) 
  }
  if("redcap_repeat_instance.y"%in% names(data_report_matrix) ) {
    data_report_matrix <- subset(data_report_matrix, select= -c(redcap_repeat_instance.y) ) 
  }
  
  # Rename column to remove the 'x'
  names(data_report_matrix)[names(data_report_matrix) == "redcap_repeat_instrument.x"] <- "redcap_repeat_instrument"
  names(data_report_matrix)[names(data_report_matrix) == "redcap_repeat_instance.x"] <- "redcap_repeat_instance"
}    
############

# Subset data to fields that has a non-null record id. It's needed because... is it needed?
# data_report_matrix <- data_report_matrix[complete.cases(data_report_matrix[ , field_name_dd[1] ]), ]

data_report_size = nrow(data_report_matrix)

col_names_report <- colnames(data_report_matrix)
report_len <- nrow(data_report_matrix)
report_cols_len <- ncol(data_report_matrix)

# If report doesn't have record id and it's using live filters, it cannot select the cases that fulfill the filter criteria
if(!field_name_dd[1]%in% names(data_report_matrix) && filter_condition != "") {
  no_record_id_n_filter <- "Plots cannot be presented when there is no record id in the report and at least a live filter has been selected"
  data_report_size <- 0
}

#### report_cols_len r report_cols_len`

```

# Advanced Graphs 

# `r project_df$project_title`
### Number of results returned: `r data_report_size`
#### `r filters_title`
#####    `r filter_title[1]`
#####    `r filter_title[2]`
#####    `r filter_title[3]`

```{r project_df$project_title , echo=FALSE, fig.height=16, fig.width=18, fig.align="center"}






#########################
# Network graphs
#########################


# Initial values
skip_loop <- 0
count_network <- 0
title_len <- 50
x_title_len <- 100
y_title_len <- 30
full_line <- 15

# If report has record id or it's not using filters, it can produce the plots
if(field_name_dd[1]%in% names(data_report_matrix) || filter_condition == "") {
  #} else {
  
  # Loops over all columns in report to create networks
  for(k in 1:report_cols_len) {
    first_field_report <- 0
    first_field_dd <- 0
    second_field_report <- 0
    second_field_dd <- 0
    # Skip some loops to prevent printing the same graph several times
    start_loop <- max(k, skip_loop)
    
    # Loops over all columns in report, starting from next column to review if it's going to be plotted
    for(i in start_loop:report_cols_len) {
      # Loops over all fields in dd to see if they are the correct type and compare field names
      for(j in 1:dd_len) {
        # Checks if fields are the plottable type
        if(field_type_dd[j] == 'text' && is.na(text_val_dd[j]) == FALSE && text_val_dd[j] != "") {
          # Do nothing
        }
        else 
          if(field_type_dd[j] == 'text' ) {
            # Checks if there are columns in the report
            if(( i > 0 )) {
              # Checks if field name in column and dd are the same
              if(col_names_report[i] == field_name_dd[j]) {
                # Assigns second field number if first one has been
                if(first_field_report > 0 && second_field_report == 0) {
                  second_field_report <- i
                  second_field_dd <- j
                  
                }
                # Assigns first field number if it hasn't been
                if(first_field_report == 0) {
                  first_field_report <- i
                  first_field_dd <- j
                }
                # Plots network if two fields have been selected
                if(first_field_report > 0 && second_field_report > 0) {
                  count_network <- count_network + 1
                  cross <- table(data_report_matrix[,first_field_report],
                                 data_report_matrix[,second_field_report])
                  
                  ########################
                  ## Align category codes
                  row_labels <- character( length = length(rownames(cross)) )
                  row_found <- 1
                  # for(i_row in rownames(cross)) {
                  #   for(i_find in 1:length(options_value[first_field_dd,])) {
                  #     # First if is to deal with not having selected any option
                  #     if(i_row == "NA") {
                  #       row_labels[row_found] <- "N/A"
                  #       row_found <- row_found + 1
                  #       break
                  #     }
                  #     # If to assign correct label to each selected option in the table
                  #     else if(is.na(options_value[first_field_dd,i_find]) == FALSE
                  #         && is.na(i_row) == FALSE
                  #         && str_trim(options_value[first_field_dd,i_find]) == i_row) {
                  #           #  print (c("options_label[first_field_dd,i_find]",
                  #           # options_label[first_field_dd,i_find]))
                  #           row_labels[row_found] <- options_label[first_field_dd,i_find]
                  #           row_found <- row_found + 1
                  #           break
                  #     }
                  #   }
                  # }
                  # rownames(cross) <- row_labels
                  # 
                  # col_labels <- character( length = length(colnames(cross)) )
                  # col_found <- 1
                  # for(i_col in colnames(cross)) {
                  #   for(i_find in 1:length(options_value[second_field_dd,])) {
                  #     # First if to deal with not selected any option
                  #     if(i_col == "NA") {
                  #       col_labels[col_found] <- "N/A"
                  #       col_found <- col_found + 1
                  #       break
                  #     }
                  #     # If to assign correct label to each selected option in the table
                  #     #else if(as.numeric(options_value[second_field_dd,i_find]) == as.numeric(i_col)) {
                  #     else if(is.na(options_value[second_field_dd,i_find]) == FALSE  && is.na(i_col) == FALSE
                  #     && str_trim(options_value[second_field_dd,i_find]) == i_col) {
                  #       col_labels[col_found] <- options_label[second_field_dd,i_find]
                  #       col_found <- col_found + 1
                  #       break
                  #     }
                  #   }
                  # }
                  # colnames(cross) <- col_labels
                  # 
                  #               ########################
                  #               ########################
                  #               # Important instruction!
                  #               # It keeps factors and formatting for the table
                  #               cross.df <- as.data.frame.matrix(cross)
                  #               ########################
                  #               ### Network graph
                  #               ########################
                  
                  # Factor names to include in graphs and maps
                  first_factor = factor(data_report_matrix[,second_field_report])
                  second_factor = factor(data_report_matrix[,first_field_report])
                  cross.table.df <- data.frame(first_factor, second_factor)
                  
                  # max_label_size <- 50
                  # # If there is a positive number of options
                  # if(!isTRUE(options_number[second_field_dd] == "") ) {
                  # 
                  #   # Auxilliary vector to reduce label size
                  #   # Copies labels into auxilliary vector
                  #   options_label_short[second_field_dd, ] <- options_label[second_field_dd, ]
                  #   # For each label
                  #   for(t in 1:options_number[second_field_dd] ) {
                  #     # Takes original label size
                  #     # If label is longer than max allowed it truncates it and adds ... at the end
                  #     if(  nchar( options_label[second_field_dd, t])  >   max_label_size  ) {
                  #       options_label_short[second_field_dd, t] <- paste(  
                  #         substr(  options_label[second_field_dd, t], 1, max_label_size), '...')
                  #     }
                  #   }
                  # 
                  #   # Replaces values in options by their label
                  #   first_factor <- mapvalues(first_factor,
                  #                             from = str_trim(options_value[second_field_dd,
                  #                                    1:options_number[second_field_dd] ]),
                  #                             to = options_label_short[second_field_dd,
                  #                                    1:options_number[second_field_dd] ]
                  #   )
                  # }
                  # 
                  #               # Condition to check that there are options for first field
                  #               # (it was throwing a NA/NaN error)
                  #               if(isTRUE(options_number[first_field_dd] == "") ) {
                  #                 # Do nothing, field has no options
                  #               }
                  #               # If there is a positive number of options
                  #               if(!isTRUE(options_number[first_field_dd] == "") ) {
                  # 
                  #                 # Auxilliary vector to reduce label size
                  #                 # Copies labels into auxilliary vector
                  #                 options_label_short[first_field_dd, ] <- options_label[first_field_dd, ]
                  #                 # For each label
                  #                 for(t in 1:options_number[first_field_dd] ) {
                  #                   # Takes original label size
                  #                   # If label is longer than max allowed it truncates it and adds ... at the end
                  #                   if(  nchar( options_label[first_field_dd, t] ) >   max_label_size  ) {
                  #                     options_label_short[first_field_dd, t] <- paste(  substr( 
                  #                       options_label[first_field_dd, t], 1, max_label_size), '...')
                  #                   }
                  #                 }
                  # 
                  #                 # Replaces values in options by their label
                  #                 second_factor <- mapvalues(second_factor,
                  #                                            from = str_trim(options_value[first_field_dd,
                  #                                                   1:options_number[first_field_dd] ]),
                  #                                            to = options_label_short[first_field_dd,
                  #                                                   1:options_number[first_field_dd] ]
                  #                 )
                  #                }
                  
                  ## Network graph
                  data_network <- data.frame(first_factor, second_factor)
                  # Selects list of unique values existing in the report for that first field
                  points_unique <- unique(data_report_matrix[,first_field_report])
                  
                  graph_title <- paste(field_label_dd[second_field_dd], "vs.",
                                       field_label_dd[first_field_dd], sep = " ")
                  graph_title <- remove_html(graph_title)
                  
                  # if(length(unique(second_factor)) > 25 ) graph_title <-
                  #   break_by_words(graph_title , title_len/2)
                  # else  graph_title <- break_by_words(graph_title , title_len)
                  # 
                  # x_label <- break_by_words(field_label_dd[second_field_dd], x_title_len)
                  # y_label <- break_by_words(field_label_dd[first_field_dd], y_title_len)
                  # too_many_cat_x <- ''
                  # too_many_cat_y <- ''
                  # # Adding warning message if there are too many categories 
                  # # in graph that cause overlapping labels or crowded graphs
                  # if(length(unique(second_factor)) > 34 ) too_many_cat_y <- 
                  #   'Too many categories! try to reduce'
                  # if(length(unique(first_factor)) > 34 ) too_many_cat_x <- 
                  #   '(Too many categories! try to reduce)'
                  
                  # legend(x=-1.5, y=-1.1, graph_title, pch=21, col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)
                  
                  network <- graph_from_data_frame(data_network, directed = TRUE)
                  plot_network <- plot(network, edge.width = 2,
                                       main = graph_title,
                                       cex.main = 25,
                                       sub = "",
                                       edge.arrow.width = 0.3,
                                       vertex.size = 5,
                                       edge.arrow.size = 0.5,
                                       vertex.size2 = 13,
                                       vertex.label.cex = 1.5,
                                       asp = 0.95,
                                       margin = -0.1)
                  
                  # # Workaround to be able to print the table outside the loop
                  # if(count_network==1) plot_network_1_1 <- plot_network
                  # if(count_network==2) plot_network_1_2 <- plot_network
                  # if(count_network==3) plot_network_1_3 <- plot_network
                  # if(count_network==4) plot_network_1_4 <- plot_network
                  # if(count_network==5) plot_network_1_5 <- plot_network
                  # if(count_network==6) plot_network_1_6 <- plot_network
                  # if(count_network==7) plot_network_1_7 <- plot_network
                  # if(count_network==8) plot_network_1_8 <- plot_network
                  # if(count_network==9) plot_network_1_9 <- plot_network
                  # if(count_network==10) plot_network_1_10 <- plot_network
                  # if(count_network==11) plot_network_1_11 <- plot_network
                  # if(count_network==12) plot_network_1_12 <- plot_network
                  # if(count_network==13) plot_network_1_13 <- plot_network
                  # if(count_network==14) plot_network_1_14 <- plot_network
                  # if(count_network==15) plot_network_1_15 <- plot_network
                  # if(count_network==16) plot_network_1_16 <- plot_network
                  # if(count_network==17) plot_network_1_17 <- plot_network
                  # if(count_network==18) plot_network_1_18 <- plot_network
                  # if(count_network==19) plot_network_1_19 <- plot_network
                  # if(count_network==20) plot_network_1_20 <- plot_network
                  # ###############
                  
                  
                  ######################
                  ######################
                  
                  printed_graphs <- TRUE
                  second_field_report <- 0
                  skip_loop <- first_field_report + 1
                }
              }
            }
          }
      }
    }
  } # k loop
} # record id in the report or no filter applied

